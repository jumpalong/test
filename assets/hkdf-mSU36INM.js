import{c as Pn,e as Jt,d as $t,a as gt,f as zn,u as Vn,g as rn,c2 as Kn,k as Zn,h as qt,F as Dn}from"./index-Bp8Ru9nj.js";import{u as Mn}from"./use-css-vars-class-DV7GkkKb.js";const Wn=Pn("divider",`
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`,[Jt("vertical",`
 margin-top: 24px;
 margin-bottom: 24px;
 `,[Jt("no-title",`
 display: flex;
 align-items: center;
 `)]),$t("title",`
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `),gt("title-position-left",[$t("line",[gt("left",{width:"28px"})])]),gt("title-position-right",[$t("line",[gt("right",{width:"28px"})])]),gt("dashed",[$t("line",`
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]),gt("vertical",`
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `),$t("line",`
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `),Jt("dashed",[$t("line",{backgroundColor:"var(--n-color)"})]),gt("dashed",[$t("line",{borderColor:"var(--n-color)"})]),gt("vertical",{backgroundColor:"var(--n-color)"})]),Gn=Object.assign(Object.assign({},rn.props),{titlePlacement:{type:String,default:"center"},dashed:Boolean,vertical:Boolean}),zo=zn({name:"Divider",props:Gn,setup(e){const{mergedClsPrefixRef:t,inlineThemeDisabled:n}=Vn(e),r=rn("Divider","-divider",Wn,Kn,e,t),o=Zn(()=>{const{common:{cubicBezierEaseInOut:i},self:{color:c,textColor:f,fontWeight:a}}=r.value;return{"--n-bezier":i,"--n-color":c,"--n-text-color":f,"--n-font-weight":a}}),s=n?Mn("divider",void 0,o,e):void 0;return{mergedClsPrefix:t,cssVars:n?void 0:o,themeClass:s==null?void 0:s.themeClass,onRender:s==null?void 0:s.onRender}},render(){var e;const{$slots:t,titlePlacement:n,vertical:r,dashed:o,cssVars:s,mergedClsPrefix:i}=this;return(e=this.onRender)===null||e===void 0||e.call(this),qt("div",{role:"separator",class:[`${i}-divider`,this.themeClass,{[`${i}-divider--vertical`]:r,[`${i}-divider--no-title`]:!t.default,[`${i}-divider--dashed`]:o,[`${i}-divider--title-position-${n}`]:t.default&&n}],style:s},r?null:qt("div",{class:`${i}-divider__line ${i}-divider__line--left`}),!r&&t.default?qt(Dn,null,qt("div",{class:`${i}-divider__title`},this.$slots),qt("div",{class:`${i}-divider__line ${i}-divider__line--right`})):null)}});function ze(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function on(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function Fn(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ze(e.outputLen),ze(e.blockLen)}function Kt(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Yn(e,t){on(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const te=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const sn=e=>e instanceof Uint8Array,ee=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),st=(e,t)=>e<<32-t|e>>>t,Xn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Xn)throw new Error("Non little-endian hardware is not supported");function Qn(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function Ae(e){if(typeof e=="string"&&(e=Qn(e)),!sn(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}function Jn(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!sn(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}let cn=class{clone(){return this._cloneInto()}};function tr(e){const t=r=>e().update(Ae(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function fn(e=32){if(te&&typeof te.getRandomValues=="function")return te.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}function er(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),c=Number(n&s),f=r?4:0,a=r?0:4;e.setUint32(t+f,i,r),e.setUint32(t+a,c,r)}let nr=class extends cn{constructor(t,n,r,o){super(),this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=ee(this.buffer)}update(t){Kt(this);const{view:n,buffer:r,blockLen:o}=this;t=Ae(t);const s=t.length;for(let i=0;i<s;){const c=Math.min(o-this.pos,s-i);if(c===o){const f=ee(t);for(;o<=s-i;i+=o)this.process(f,i);continue}r.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Kt(this),Yn(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;n[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(r,0),i=0);for(let l=i;l<o;l++)n[l]=0;er(r,o-8,BigInt(this.length*8),s),this.process(r,0);const c=ee(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)c.setUint32(4*l,u[l],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:c}=this;return t.length=o,t.pos=c,t.finished=s,t.destroyed=i,o%n&&t.buffer.set(r),t}};const rr=(e,t,n)=>e&t^~e&n,or=(e,t,n)=>e&t^e&n^t&n,sr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),pt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),yt=new Uint32Array(64);let ir=class extends nr{constructor(){super(64,32,8,!1),this.A=pt[0]|0,this.B=pt[1]|0,this.C=pt[2]|0,this.D=pt[3]|0,this.E=pt[4]|0,this.F=pt[5]|0,this.G=pt[6]|0,this.H=pt[7]|0}get(){const{A:t,B:n,C:r,D:o,E:s,F:i,G:c,H:f}=this;return[t,n,r,o,s,i,c,f]}set(t,n,r,o,s,i,c,f){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=f|0}process(t,n){for(let l=0;l<16;l++,n+=4)yt[l]=t.getUint32(n,!1);for(let l=16;l<64;l++){const b=yt[l-15],y=yt[l-2],w=st(b,7)^st(b,18)^b>>>3,h=st(y,17)^st(y,19)^y>>>10;yt[l]=h+yt[l-7]+w+yt[l-16]|0}let{A:r,B:o,C:s,D:i,E:c,F:f,G:a,H:u}=this;for(let l=0;l<64;l++){const b=st(c,6)^st(c,11)^st(c,25),y=u+b+rr(c,f,a)+sr[l]+yt[l]|0,h=(st(r,2)^st(r,13)^st(r,22))+or(r,o,s)|0;u=a,a=f,f=c,c=i+y|0,i=s,s=o,o=r,r=y+h|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(r,o,s,i,c,f,a,u)}roundClean(){yt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const le=tr(()=>new ir);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const an=BigInt(0),Gt=BigInt(1),cr=BigInt(2),Ft=e=>e instanceof Uint8Array,fr=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function _t(e){if(!Ft(e))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=fr[e[n]];return t}function ln(e){const t=e.toString(16);return t.length&1?`0${t}`:t}function Be(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return BigInt(e===""?"0":`0x${e}`)}function Ct(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let r=0;r<n.length;r++){const o=r*2,s=e.slice(o,o+2),i=Number.parseInt(s,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");n[r]=i}return n}function Y(e){return Be(_t(e))}function ve(e){if(!Ft(e))throw new Error("Uint8Array expected");return Be(_t(Uint8Array.from(e).reverse()))}function At(e,t){return Ct(e.toString(16).padStart(t*2,"0"))}function $e(e,t){return At(e,t).reverse()}function ar(e){return Ct(ln(e))}function M(e,t,n){let r;if(typeof t=="string")try{r=Ct(t)}catch(s){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`)}else if(Ft(t))r=Uint8Array.from(t);else throw new Error(`${e} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${e} expected ${n} bytes, got ${o}`);return r}function Lt(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!Ft(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}function lr(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function ur(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function hr(e){let t;for(t=0;e>an;e>>=Gt,t+=1);return t}function dr(e,t){return e>>BigInt(t)&Gt}const wr=(e,t,n)=>e|(n?Gt:an)<<BigInt(t),Ie=e=>(cr<<BigInt(e-1))-Gt,ne=e=>new Uint8Array(e),Ve=e=>Uint8Array.from(e);function un(e,t,n){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=ne(e),o=ne(e),s=0;const i=()=>{r.fill(1),o.fill(0),s=0},c=(...l)=>n(o,r,...l),f=(l=ne())=>{o=c(Ve([0]),l),r=c(),l.length!==0&&(o=c(Ve([1]),l),r=c())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const b=[];for(;l<t;){r=c();const y=r.slice();b.push(y),l+=r.length}return Lt(...b)};return(l,b)=>{i(),f(l);let y;for(;!(y=b(a()));)f();return i(),y}}const gr={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||e instanceof Uint8Array,isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function zt(e,t,n={}){const r=(o,s,i)=>{const c=gr[s];if(typeof c!="function")throw new Error(`Invalid validator "${s}", expected function`);const f=e[o];if(!(i&&f===void 0)&&!c(f,e))throw new Error(`Invalid param ${String(o)}=${f} (${typeof f}), expected ${s}`)};for(const[o,s]of Object.entries(t))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return e}const pr=Object.freeze(Object.defineProperty({__proto__:null,bitGet:dr,bitLen:hr,bitMask:Ie,bitSet:wr,bytesToHex:_t,bytesToNumberBE:Y,bytesToNumberLE:ve,concatBytes:Lt,createHmacDrbg:un,ensureBytes:M,equalBytes:lr,hexToBytes:Ct,hexToNumber:Be,numberToBytesBE:At,numberToBytesLE:$e,numberToHexUnpadded:ln,numberToVarBytesBE:ar,utf8ToBytes:ur,validateObject:zt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const K=BigInt(0),P=BigInt(1),It=BigInt(2),yr=BigInt(3),ue=BigInt(4),Ke=BigInt(5),Ze=BigInt(8);BigInt(9);BigInt(16);function D(e,t){const n=e%t;return n>=K?n:t+n}function br(e,t,n){if(n<=K||t<K)throw new Error("Expected power/modulo > 0");if(n===P)return K;let r=P;for(;t>K;)t&P&&(r=r*e%n),e=e*e%n,t>>=P;return r}function J(e,t,n){let r=e;for(;t-- >K;)r*=r,r%=n;return r}function he(e,t){if(e===K||t<=K)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let n=D(e,t),r=t,o=K,s=P;for(;n!==K;){const c=r/n,f=r%n,a=o-s*c;r=n,n=f,o=s,s=a}if(r!==P)throw new Error("invert: does not exist");return D(o,t)}function xr(e){const t=(e-P)/It;let n,r,o;for(n=e-P,r=0;n%It===K;n/=It,r++);for(o=It;o<e&&br(o,t,e)!==e-P;o++);if(r===1){const i=(e+P)/ue;return function(f,a){const u=f.pow(a,i);if(!f.eql(f.sqr(u),a))throw new Error("Cannot find square root");return u}}const s=(n+P)/It;return function(c,f){if(c.pow(f,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,u=c.pow(c.mul(c.ONE,o),n),l=c.pow(f,s),b=c.pow(f,n);for(;!c.eql(b,c.ONE);){if(c.eql(b,c.ZERO))return c.ZERO;let y=1;for(let h=c.sqr(b);y<a&&!c.eql(h,c.ONE);y++)h=c.sqr(h);const w=c.pow(u,P<<BigInt(a-y-1));u=c.sqr(w),l=c.mul(l,w),b=c.mul(b,u),a=y}return l}}function Er(e){if(e%ue===yr){const t=(e+P)/ue;return function(r,o){const s=r.pow(o,t);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(e%Ze===Ke){const t=(e-Ke)/Ze;return function(r,o){const s=r.mul(o,It),i=r.pow(s,t),c=r.mul(o,i),f=r.mul(r.mul(c,It),i),a=r.mul(c,r.sub(f,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return xr(e)}const mr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ar(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=mr.reduce((r,o)=>(r[o]="function",r),t);return zt(e,n)}function Br(e,t,n){if(n<K)throw new Error("Expected power > 0");if(n===K)return e.ONE;if(n===P)return t;let r=e.ONE,o=t;for(;n>K;)n&P&&(r=e.mul(r,o)),o=e.sqr(o),n>>=P;return r}function vr(e,t){const n=new Array(t.length),r=t.reduce((s,i,c)=>e.is0(i)?s:(n[c]=s,e.mul(s,i)),e.ONE),o=e.inv(r);return t.reduceRight((s,i,c)=>e.is0(i)?s:(n[c]=e.mul(s,n[c]),e.mul(s,i)),o),n}function hn(e,t){const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function $r(e,t,n=!1,r={}){if(e<=K)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:o,nByteLength:s}=hn(e,t);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=Er(e),c=Object.freeze({ORDER:e,BITS:o,BYTES:s,MASK:Ie(o),ZERO:K,ONE:P,create:f=>D(f,e),isValid:f=>{if(typeof f!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);return K<=f&&f<e},is0:f=>f===K,isOdd:f=>(f&P)===P,neg:f=>D(-f,e),eql:(f,a)=>f===a,sqr:f=>D(f*f,e),add:(f,a)=>D(f+a,e),sub:(f,a)=>D(f-a,e),mul:(f,a)=>D(f*a,e),pow:(f,a)=>Br(c,f,a),div:(f,a)=>D(f*he(a,e),e),sqrN:f=>f*f,addN:(f,a)=>f+a,subN:(f,a)=>f-a,mulN:(f,a)=>f*a,inv:f=>he(f,e),sqrt:r.sqrt||(f=>i(c,f)),invertBatch:f=>vr(c,f),cmov:(f,a,u)=>u?a:f,toBytes:f=>n?$e(f,s):At(f,s),fromBytes:f=>{if(f.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${f.length}`);return n?ve(f):Y(f)}});return Object.freeze(c)}function dn(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function wn(e){const t=dn(e);return t+Math.ceil(t/2)}function Ir(e,t,n=!1){const r=e.length,o=dn(t),s=wn(t);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const i=n?Y(e):ve(e),c=D(i,t-P)+P;return n?$e(c,o):At(c,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ur=BigInt(0),re=BigInt(1);function Lr(e,t){const n=(o,s)=>{const i=s.negate();return o?i:s},r=o=>{const s=Math.ceil(t/o)+1,i=2**(o-1);return{windows:s,windowSize:i}};return{constTimeNegate:n,unsafeLadder(o,s){let i=e.ZERO,c=o;for(;s>Ur;)s&re&&(i=i.add(c)),c=c.double(),s>>=re;return i},precomputeWindow(o,s){const{windows:i,windowSize:c}=r(s),f=[];let a=o,u=a;for(let l=0;l<i;l++){u=a,f.push(u);for(let b=1;b<c;b++)u=u.add(a),f.push(u);a=u.double()}return f},wNAF(o,s,i){const{windows:c,windowSize:f}=r(o);let a=e.ZERO,u=e.BASE;const l=BigInt(2**o-1),b=2**o,y=BigInt(o);for(let w=0;w<c;w++){const h=w*f;let d=Number(i&l);i>>=y,d>f&&(d-=b,i+=re);const g=h,A=h+Math.abs(d)-1,I=w%2!==0,H=d<0;d===0?u=u.add(n(I,s[g])):a=a.add(n(H,s[A]))}return{p:a,f:u}},wNAFCached(o,s,i,c){const f=o._WINDOW_SIZE||1;let a=s.get(o);return a||(a=this.precomputeWindow(o,f),f!==1&&s.set(o,c(a))),this.wNAF(f,a,i)}}}function gn(e){return Ar(e.Fp),zt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...hn(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Sr(e){const t=gn(e);zt(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=t;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:Hr,hexToBytes:Tr}=pr,Ut={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(e){const{Err:t}=Ut;if(e.length<2||e[0]!==2)throw new t("Invalid signature integer tag");const n=e[1],r=e.subarray(2,n+2);if(!n||r.length!==n)throw new t("Invalid signature integer: wrong length");if(r[0]&128)throw new t("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Hr(r),l:e.subarray(n+2)}},toSig(e){const{Err:t}=Ut,n=typeof e=="string"?Tr(e):e;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new t("Invalid signature tag");if(n[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:o,l:s}=Ut._parseInt(n.subarray(2)),{d:i,l:c}=Ut._parseInt(s);if(c.length)throw new t("Invalid signature: left bytes after parsing");return{r:o,s:i}},hexFromSig(e){const t=a=>Number.parseInt(a[0],16)&8?"00"+a:a,n=a=>{const u=a.toString(16);return u.length&1?`0${u}`:u},r=t(n(e.s)),o=t(n(e.r)),s=r.length/2,i=o.length/2,c=n(s),f=n(i);return`30${n(i+s+4)}02${f}${o}02${c}${r}`}},ut=BigInt(0),tt=BigInt(1);BigInt(2);const De=BigInt(3);BigInt(4);function Nr(e){const t=Sr(e),{Fp:n}=t,r=t.toBytes||((w,h,d)=>{const g=h.toAffine();return Lt(Uint8Array.from([4]),n.toBytes(g.x),n.toBytes(g.y))}),o=t.fromBytes||(w=>{const h=w.subarray(1),d=n.fromBytes(h.subarray(0,n.BYTES)),g=n.fromBytes(h.subarray(n.BYTES,2*n.BYTES));return{x:d,y:g}});function s(w){const{a:h,b:d}=t,g=n.sqr(w),A=n.mul(g,w);return n.add(n.add(A,n.mul(w,h)),d)}if(!n.eql(n.sqr(t.Gy),s(t.Gx)))throw new Error("bad generator point: equation left != right");function i(w){return typeof w=="bigint"&&ut<w&&w<t.n}function c(w){if(!i(w))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function f(w){const{allowedPrivateKeyLengths:h,nByteLength:d,wrapPrivateKey:g,n:A}=t;if(h&&typeof w!="bigint"){if(w instanceof Uint8Array&&(w=_t(w)),typeof w!="string"||!h.includes(w.length))throw new Error("Invalid key");w=w.padStart(d*2,"0")}let I;try{I=typeof w=="bigint"?w:Y(M("private key",w,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof w}`)}return g&&(I=D(I,A)),c(I),I}const a=new Map;function u(w){if(!(w instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(h,d,g){if(this.px=h,this.py=d,this.pz=g,h==null||!n.isValid(h))throw new Error("x required");if(d==null||!n.isValid(d))throw new Error("y required");if(g==null||!n.isValid(g))throw new Error("z required")}static fromAffine(h){const{x:d,y:g}=h||{};if(!h||!n.isValid(d)||!n.isValid(g))throw new Error("invalid affine point");if(h instanceof l)throw new Error("projective point not allowed");const A=I=>n.eql(I,n.ZERO);return A(d)&&A(g)?l.ZERO:new l(d,g,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const d=n.invertBatch(h.map(g=>g.pz));return h.map((g,A)=>g.toAffine(d[A])).map(l.fromAffine)}static fromHex(h){const d=l.fromAffine(o(M("pointHex",h)));return d.assertValidity(),d}static fromPrivateKey(h){return l.BASE.multiply(f(h))}_setWindowSize(h){this._WINDOW_SIZE=h,a.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:h,y:d}=this.toAffine();if(!n.isValid(h)||!n.isValid(d))throw new Error("bad point: x or y not FE");const g=n.sqr(d),A=s(h);if(!n.eql(g,A))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:h}=this.toAffine();if(n.isOdd)return!n.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){u(h);const{px:d,py:g,pz:A}=this,{px:I,py:H,pz:T}=h,m=n.eql(n.mul(d,T),n.mul(I,A)),B=n.eql(n.mul(g,T),n.mul(H,A));return m&&B}negate(){return new l(this.px,n.neg(this.py),this.pz)}double(){const{a:h,b:d}=t,g=n.mul(d,De),{px:A,py:I,pz:H}=this;let T=n.ZERO,m=n.ZERO,B=n.ZERO,$=n.mul(A,A),_=n.mul(I,I),S=n.mul(H,H),U=n.mul(A,I);return U=n.add(U,U),B=n.mul(A,H),B=n.add(B,B),T=n.mul(h,B),m=n.mul(g,S),m=n.add(T,m),T=n.sub(_,m),m=n.add(_,m),m=n.mul(T,m),T=n.mul(U,T),B=n.mul(g,B),S=n.mul(h,S),U=n.sub($,S),U=n.mul(h,U),U=n.add(U,B),B=n.add($,$),$=n.add(B,$),$=n.add($,S),$=n.mul($,U),m=n.add(m,$),S=n.mul(I,H),S=n.add(S,S),$=n.mul(S,U),T=n.sub(T,$),B=n.mul(S,_),B=n.add(B,B),B=n.add(B,B),new l(T,m,B)}add(h){u(h);const{px:d,py:g,pz:A}=this,{px:I,py:H,pz:T}=h;let m=n.ZERO,B=n.ZERO,$=n.ZERO;const _=t.a,S=n.mul(t.b,De);let U=n.mul(d,I),C=n.mul(g,H),O=n.mul(A,T),k=n.add(d,g),p=n.add(I,H);k=n.mul(k,p),p=n.add(U,C),k=n.sub(k,p),p=n.add(d,A);let x=n.add(I,T);return p=n.mul(p,x),x=n.add(U,O),p=n.sub(p,x),x=n.add(g,A),m=n.add(H,T),x=n.mul(x,m),m=n.add(C,O),x=n.sub(x,m),$=n.mul(_,p),m=n.mul(S,O),$=n.add(m,$),m=n.sub(C,$),$=n.add(C,$),B=n.mul(m,$),C=n.add(U,U),C=n.add(C,U),O=n.mul(_,O),p=n.mul(S,p),C=n.add(C,O),O=n.sub(U,O),O=n.mul(_,O),p=n.add(p,O),U=n.mul(C,p),B=n.add(B,U),U=n.mul(x,p),m=n.mul(k,m),m=n.sub(m,U),U=n.mul(k,C),$=n.mul(x,$),$=n.add($,U),new l(m,B,$)}subtract(h){return this.add(h.negate())}is0(){return this.equals(l.ZERO)}wNAF(h){return y.wNAFCached(this,a,h,d=>{const g=n.invertBatch(d.map(A=>A.pz));return d.map((A,I)=>A.toAffine(g[I])).map(l.fromAffine)})}multiplyUnsafe(h){const d=l.ZERO;if(h===ut)return d;if(c(h),h===tt)return this;const{endo:g}=t;if(!g)return y.unsafeLadder(this,h);let{k1neg:A,k1:I,k2neg:H,k2:T}=g.splitScalar(h),m=d,B=d,$=this;for(;I>ut||T>ut;)I&tt&&(m=m.add($)),T&tt&&(B=B.add($)),$=$.double(),I>>=tt,T>>=tt;return A&&(m=m.negate()),H&&(B=B.negate()),B=new l(n.mul(B.px,g.beta),B.py,B.pz),m.add(B)}multiply(h){c(h);let d=h,g,A;const{endo:I}=t;if(I){const{k1neg:H,k1:T,k2neg:m,k2:B}=I.splitScalar(d);let{p:$,f:_}=this.wNAF(T),{p:S,f:U}=this.wNAF(B);$=y.constTimeNegate(H,$),S=y.constTimeNegate(m,S),S=new l(n.mul(S.px,I.beta),S.py,S.pz),g=$.add(S),A=_.add(U)}else{const{p:H,f:T}=this.wNAF(d);g=H,A=T}return l.normalizeZ([g,A])[0]}multiplyAndAddUnsafe(h,d,g){const A=l.BASE,I=(T,m)=>m===ut||m===tt||!T.equals(A)?T.multiplyUnsafe(m):T.multiply(m),H=I(this,d).add(I(h,g));return H.is0()?void 0:H}toAffine(h){const{px:d,py:g,pz:A}=this,I=this.is0();h==null&&(h=I?n.ONE:n.inv(A));const H=n.mul(d,h),T=n.mul(g,h),m=n.mul(A,h);if(I)return{x:n.ZERO,y:n.ZERO};if(!n.eql(m,n.ONE))throw new Error("invZ was invalid");return{x:H,y:T}}isTorsionFree(){const{h,isTorsionFree:d}=t;if(h===tt)return!0;if(d)return d(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:d}=t;return h===tt?this:d?d(l,this):this.multiplyUnsafe(t.h)}toRawBytes(h=!0){return this.assertValidity(),r(l,this,h)}toHex(h=!0){return _t(this.toRawBytes(h))}}l.BASE=new l(t.Gx,t.Gy,n.ONE),l.ZERO=new l(n.ZERO,n.ONE,n.ZERO);const b=t.nBitLength,y=Lr(l,t.endo?Math.ceil(b/2):b);return{CURVE:t,ProjectivePoint:l,normPrivateKeyToScalar:f,weierstrassEquation:s,isWithinCurveOrder:i}}function _r(e){const t=gn(e);return zt(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function Cr(e){const t=_r(e),{Fp:n,n:r}=t,o=n.BYTES+1,s=2*n.BYTES+1;function i(p){return ut<p&&p<n.ORDER}function c(p){return D(p,r)}function f(p){return he(p,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:u,weierstrassEquation:l,isWithinCurveOrder:b}=Nr({...t,toBytes(p,x,v){const L=x.toAffine(),E=n.toBytes(L.x),N=Lt;return v?N(Uint8Array.from([x.hasEvenY()?2:3]),E):N(Uint8Array.from([4]),E,n.toBytes(L.y))},fromBytes(p){const x=p.length,v=p[0],L=p.subarray(1);if(x===o&&(v===2||v===3)){const E=Y(L);if(!i(E))throw new Error("Point is not on curve");const N=l(E);let q=n.sqrt(N);const R=(q&tt)===tt;return(v&1)===1!==R&&(q=n.neg(q)),{x:E,y:q}}else if(x===s&&v===4){const E=n.fromBytes(L.subarray(0,n.BYTES)),N=n.fromBytes(L.subarray(n.BYTES,2*n.BYTES));return{x:E,y:N}}else throw new Error(`Point of length ${x} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),y=p=>_t(At(p,t.nByteLength));function w(p){const x=r>>tt;return p>x}function h(p){return w(p)?c(-p):p}const d=(p,x,v)=>Y(p.slice(x,v));class g{constructor(x,v,L){this.r=x,this.s=v,this.recovery=L,this.assertValidity()}static fromCompact(x){const v=t.nByteLength;return x=M("compactSignature",x,v*2),new g(d(x,0,v),d(x,v,2*v))}static fromDER(x){const{r:v,s:L}=Ut.toSig(M("DER",x));return new g(v,L)}assertValidity(){if(!b(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!b(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(x){return new g(this.r,this.s,x)}recoverPublicKey(x){const{r:v,s:L,recovery:E}=this,N=B(M("msgHash",x));if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");const q=E===2||E===3?v+t.n:v;if(q>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const R=E&1?"03":"02",V=a.fromHex(R+y(q)),W=f(q),X=c(-N*W),Q=c(L*W),G=a.BASE.multiplyAndAddUnsafe(V,X,Q);if(!G)throw new Error("point at infinify");return G.assertValidity(),G}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Ct(this.toDERHex())}toDERHex(){return Ut.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Ct(this.toCompactHex())}toCompactHex(){return y(this.r)+y(this.s)}}const A={isValidPrivateKey(p){try{return u(p),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const p=wn(t.n);return Ir(t.randomBytes(p),t.n)},precompute(p=8,x=a.BASE){return x._setWindowSize(p),x.multiply(BigInt(3)),x}};function I(p,x=!0){return a.fromPrivateKey(p).toRawBytes(x)}function H(p){const x=p instanceof Uint8Array,v=typeof p=="string",L=(x||v)&&p.length;return x?L===o||L===s:v?L===2*o||L===2*s:p instanceof a}function T(p,x,v=!0){if(H(p))throw new Error("first arg must be private key");if(!H(x))throw new Error("second arg must be public key");return a.fromHex(x).multiply(u(p)).toRawBytes(v)}const m=t.bits2int||function(p){const x=Y(p),v=p.length*8-t.nBitLength;return v>0?x>>BigInt(v):x},B=t.bits2int_modN||function(p){return c(m(p))},$=Ie(t.nBitLength);function _(p){if(typeof p!="bigint")throw new Error("bigint expected");if(!(ut<=p&&p<$))throw new Error(`bigint expected < 2^${t.nBitLength}`);return At(p,t.nByteLength)}function S(p,x,v=U){if(["recovered","canonical"].some(F=>F in v))throw new Error("sign() legacy options not supported");const{hash:L,randomBytes:E}=t;let{lowS:N,prehash:q,extraEntropy:R}=v;N==null&&(N=!0),p=M("msgHash",p),q&&(p=M("prehashed msgHash",L(p)));const V=B(p),W=u(x),X=[_(W),_(V)];if(R!=null){const F=R===!0?E(n.BYTES):R;X.push(M("extraEntropy",F))}const Q=Lt(...X),G=V;function ot(F){const St=m(F);if(!b(St))return;const ke=f(St),Ht=a.BASE.multiply(St).toAffine(),rt=c(Ht.x);if(rt===ut)return;const Tt=c(ke*c(G+rt*W));if(Tt===ut)return;let je=(Ht.x===rt?0:2)|Number(Ht.y&tt),Pe=Tt;return N&&w(Tt)&&(Pe=h(Tt),je^=1),new g(rt,Pe,je)}return{seed:Q,k2sig:ot}}const U={lowS:t.lowS,prehash:!1},C={lowS:t.lowS,prehash:!1};function O(p,x,v=U){const{seed:L,k2sig:E}=S(p,x,v),N=t;return un(N.hash.outputLen,N.nByteLength,N.hmac)(L,E)}a.BASE._setWindowSize(8);function k(p,x,v,L=C){var Ht;const E=p;if(x=M("msgHash",x),v=M("publicKey",v),"strict"in L)throw new Error("options.strict was renamed to lowS");const{lowS:N,prehash:q}=L;let R,V;try{if(typeof E=="string"||E instanceof Uint8Array)try{R=g.fromDER(E)}catch(rt){if(!(rt instanceof Ut.Err))throw rt;R=g.fromCompact(E)}else if(typeof E=="object"&&typeof E.r=="bigint"&&typeof E.s=="bigint"){const{r:rt,s:Tt}=E;R=new g(rt,Tt)}else throw new Error("PARSE");V=a.fromHex(v)}catch(rt){if(rt.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(N&&R.hasHighS())return!1;q&&(x=t.hash(x));const{r:W,s:X}=R,Q=B(x),G=f(X),ot=c(Q*G),F=c(W*G),St=(Ht=a.BASE.multiplyAndAddUnsafe(V,ot,F))==null?void 0:Ht.toAffine();return St?c(St.x)===W:!1}return{CURVE:t,getPublicKey:I,getSharedSecret:T,sign:O,verify:k,ProjectivePoint:a,Signature:g,utils:A}}let pn=class extends cn{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,Fn(t);const r=Ae(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),s.fill(0)}update(t){return Kt(this),this.iHash.update(t),this}digestInto(t){Kt(this),on(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=c,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const yn=(e,t,n)=>new pn(e,t).update(n).digest();yn.create=(e,t)=>new pn(e,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Or(e){return{hash:e,hmac:(t,...n)=>yn(e,t,Jn(...n)),randomBytes:fn}}function Rr(e,t){const n=r=>Cr({...e,...Or(r)});return Object.freeze({...n(t),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Zt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),bn=BigInt(1),Dt=BigInt(2),Me=(e,t)=>(e+t/Dt)/t;function xn(e){const t=Yt,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),c=BigInt(44),f=BigInt(88),a=e*e*e%t,u=a*a*e%t,l=J(u,n,t)*u%t,b=J(l,n,t)*u%t,y=J(b,Dt,t)*a%t,w=J(y,o,t)*y%t,h=J(w,s,t)*w%t,d=J(h,c,t)*h%t,g=J(d,f,t)*d%t,A=J(g,c,t)*h%t,I=J(A,n,t)*u%t,H=J(I,i,t)*w%t,T=J(H,r,t)*a%t,m=J(T,Dt,t);if(!de.eql(de.sqr(m),e))throw new Error("Cannot find square root");return m}const de=$r(Yt,void 0,void 0,{sqrt:xn}),Ue=Rr({a:BigInt(0),b:BigInt(7),Fp:de,n:Zt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=Zt,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-bn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,i=BigInt("0x100000000000000000000000000000000"),c=Me(s*e,t),f=Me(-r*e,t);let a=D(e-c*n-f*o,t),u=D(-c*r-f*s,t);const l=a>i,b=u>i;if(l&&(a=t-a),b&&(u=t-u),a>i||u>i)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:l,k1:a,k2neg:b,k2:u}}}},le),Xt=BigInt(0),En=e=>typeof e=="bigint"&&Xt<e&&e<Yt,qr=e=>typeof e=="bigint"&&Xt<e&&e<Zt,We={};function Mt(e,...t){let n=We[e];if(n===void 0){const r=le(Uint8Array.from(e,o=>o.charCodeAt(0)));n=Lt(r,r),We[e]=n}return le(Lt(n,...t))}const Le=e=>e.toRawBytes(!0).slice(1),we=e=>At(e,32),oe=e=>D(e,Yt),jt=e=>D(e,Zt),Se=Ue.ProjectivePoint,kr=(e,t,n)=>Se.BASE.multiplyAndAddUnsafe(e,t,n);function ge(e){let t=Ue.utils.normPrivateKeyToScalar(e),n=Se.fromPrivateKey(t);return{scalar:n.hasEvenY()?t:jt(-t),bytes:Le(n)}}function mn(e){if(!En(e))throw new Error("bad x: need 0 < x < p");const t=oe(e*e),n=oe(t*e+BigInt(7));let r=xn(n);r%Dt!==Xt&&(r=oe(-r));const o=new Se(e,r,bn);return o.assertValidity(),o}function An(...e){return jt(Y(Mt("BIP0340/challenge",...e)))}function jr(e){return ge(e).bytes}function Pr(e,t,n=fn(32)){const r=M("message",e),{bytes:o,scalar:s}=ge(t),i=M("auxRand",n,32),c=we(s^Y(Mt("BIP0340/aux",i))),f=Mt("BIP0340/nonce",c,o,r),a=jt(Y(f));if(a===Xt)throw new Error("sign failed: k is zero");const{bytes:u,scalar:l}=ge(a),b=An(u,o,r),y=new Uint8Array(64);if(y.set(u,0),y.set(we(jt(l+b*s)),32),!Bn(y,r,o))throw new Error("sign: Invalid signature produced");return y}function Bn(e,t,n){const r=M("signature",e,64),o=M("message",t),s=M("publicKey",n,32);try{const i=mn(Y(s)),c=Y(r.subarray(0,32));if(!En(c))return!1;const f=Y(r.subarray(32,64));if(!qr(f))return!1;const a=An(we(c),Le(i),o),u=kr(i,f,jt(-a));return!(!u||!u.hasEvenY()||u.toAffine().x!==c)}catch{return!1}}const Wo={getPublicKey:jr,sign:Pr,verify:Bn,utils:{randomPrivateKey:Ue.utils.randomPrivateKey,lift_x:mn,pointToBytes:Le,numberToBytesBE:At,bytesToNumberBE:Y,taggedHash:Mt,mod:D}},se=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const He=e=>e instanceof Uint8Array,ie=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),it=(e,t)=>e<<32-t|e>>>t,zr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!zr)throw new Error("Non little-endian hardware is not supported");const Vr=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Go(e){if(!He(e))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=Vr[e[n]];return t}function Fo(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let r=0;r<n.length;r++){const o=r*2,s=e.slice(o,o+2),i=Number.parseInt(s,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");n[r]=i}return n}function Kr(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function Pt(e){if(typeof e=="string"&&(e=Kr(e)),!He(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}function Yo(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!He(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}class vn{clone(){return this._cloneInto()}}function $n(e){const t=r=>e().update(Pt(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function Xo(e=32){if(se&&typeof se.getRandomValues=="function")return se.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}function pe(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function Zr(e){if(typeof e!="boolean")throw new Error(`Expected boolean, not ${e}`)}function In(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function Dr(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");pe(e.outputLen),pe(e.blockLen)}function Mr(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Wr(e,t){In(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const ft={number:pe,bool:Zr,bytes:In,hash:Dr,exists:Mr,output:Wr};function Gr(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),c=Number(n&s),f=r?4:0,a=r?0:4;e.setUint32(t+f,i,r),e.setUint32(t+a,c,r)}class Fr extends vn{constructor(t,n,r,o){super(),this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=ie(this.buffer)}update(t){ft.exists(this);const{view:n,buffer:r,blockLen:o}=this;t=Pt(t);const s=t.length;for(let i=0;i<s;){const c=Math.min(o-this.pos,s-i);if(c===o){const f=ie(t);for(;o<=s-i;i+=o)this.process(f,i);continue}r.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ft.exists(this),ft.output(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;n[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(r,0),i=0);for(let l=i;l<o;l++)n[l]=0;Gr(r,o-8,BigInt(this.length*8),s),this.process(r,0);const c=ie(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)c.setUint32(4*l,u[l],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:c}=this;return t.length=o,t.pos=c,t.finished=s,t.destroyed=i,o%n&&t.buffer.set(r),t}}const Yr=(e,t,n)=>e&t^~e&n,Xr=(e,t,n)=>e&t^e&n^t&n,Qr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),bt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),xt=new Uint32Array(64);class Un extends Fr{constructor(){super(64,32,8,!1),this.A=bt[0]|0,this.B=bt[1]|0,this.C=bt[2]|0,this.D=bt[3]|0,this.E=bt[4]|0,this.F=bt[5]|0,this.G=bt[6]|0,this.H=bt[7]|0}get(){const{A:t,B:n,C:r,D:o,E:s,F:i,G:c,H:f}=this;return[t,n,r,o,s,i,c,f]}set(t,n,r,o,s,i,c,f){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=f|0}process(t,n){for(let l=0;l<16;l++,n+=4)xt[l]=t.getUint32(n,!1);for(let l=16;l<64;l++){const b=xt[l-15],y=xt[l-2],w=it(b,7)^it(b,18)^b>>>3,h=it(y,17)^it(y,19)^y>>>10;xt[l]=h+xt[l-7]+w+xt[l-16]|0}let{A:r,B:o,C:s,D:i,E:c,F:f,G:a,H:u}=this;for(let l=0;l<64;l++){const b=it(c,6)^it(c,11)^it(c,25),y=u+b+Yr(c,f,a)+Qr[l]+xt[l]|0,h=(it(r,2)^it(r,13)^it(r,22))+Xr(r,o,s)|0;u=a,a=f,f=c,c=i+y|0,i=s,s=o,o=r,r=y+h|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(r,o,s,i,c,f,a,u)}roundClean(){xt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class Jr extends Un{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Qo=$n(()=>new Un);$n(()=>new Jr);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Rt(e){if(!Number.isSafeInteger(e))throw new Error(`Wrong integer: ${e}`)}function ht(...e){const t=(o,s)=>i=>o(s(i)),n=Array.from(e).reverse().reduce((o,s)=>o?t(o,s.encode):s.encode,void 0),r=e.reduce((o,s)=>o?t(o,s.decode):s.decode,void 0);return{encode:n,decode:r}}function dt(e){return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return t.map(n=>{if(Rt(n),n<0||n>=e.length)throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${e.length})`);return e[n]})},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("alphabet.decode input should be array of strings");return t.map(n=>{if(typeof n!="string")throw new Error(`alphabet.decode: not string element=${n}`);const r=e.indexOf(n);if(r===-1)throw new Error(`Unknown letter: "${n}". Allowed: ${e}`);return r})}}}function wt(e=""){if(typeof e!="string")throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("join.encode input should be array of strings");for(let n of t)if(typeof n!="string")throw new Error(`join.encode: non-string input=${n}`);return t.join(e)},decode:t=>{if(typeof t!="string")throw new Error("join.decode input should be string");return t.split(e)}}}function Qt(e,t="="){if(Rt(e),typeof t!="string")throw new Error("padding chr should be string");return{encode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let r of n)if(typeof r!="string")throw new Error(`padding.encode: non-string input=${r}`);for(;n.length*e%8;)n.push(t);return n},decode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let o of n)if(typeof o!="string")throw new Error(`padding.decode: non-string input=${o}`);let r=n.length;if(r*e%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;r>0&&n[r-1]===t;r--)if(!((r-1)*e%8))throw new Error("Invalid padding: string has too much padding");return n.slice(0,r)}}}function Ln(e){if(typeof e!="function")throw new Error("normalize fn should be function");return{encode:t=>t,decode:t=>e(t)}}function Ge(e,t,n){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(e))throw new Error("convertRadix: data should be array");if(!e.length)return[];let r=0;const o=[],s=Array.from(e);for(s.forEach(i=>{if(Rt(i),i<0||i>=t)throw new Error(`Wrong integer: ${i}`)});;){let i=0,c=!0;for(let f=r;f<s.length;f++){const a=s[f],u=t*i+a;if(!Number.isSafeInteger(u)||t*i/t!==i||u-a!==t*i)throw new Error("convertRadix: carry overflow");if(i=u%n,s[f]=Math.floor(u/n),!Number.isSafeInteger(s[f])||s[f]*n+i!==u)throw new Error("convertRadix: carry overflow");if(c)s[f]?c=!1:r=f;else continue}if(o.push(i),c)break}for(let i=0;i<e.length-1&&e[i]===0;i++)o.push(0);return o.reverse()}const Sn=(e,t)=>t?Sn(t,e%t):e,Wt=(e,t)=>e+(t-Sn(e,t));function ye(e,t,n,r){if(!Array.isArray(e))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(Wt(t,n)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${Wt(t,n)}`);let o=0,s=0;const i=2**n-1,c=[];for(const f of e){if(Rt(f),f>=2**t)throw new Error(`convertRadix2: invalid data word=${f} from=${t}`);if(o=o<<t|f,s+t>32)throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);for(s+=t;s>=n;s-=n)c.push((o>>s-n&i)>>>0);o&=2**s-1}if(o=o<<n-s&i,!r&&s>=t)throw new Error("Excess padding");if(!r&&o)throw new Error(`Non-zero padding: ${o}`);return r&&s>0&&c.push(o>>>0),c}function to(e){return Rt(e),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return Ge(Array.from(t),2**8,e)},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(Ge(t,e,2**8))}}}function vt(e,t=!1){if(Rt(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(Wt(8,e)>32||Wt(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!(n instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return ye(Array.from(n),8,e,!t)},decode:n=>{if(!Array.isArray(n)||n.length&&typeof n[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(ye(n,e,8,t))}}}function Fe(e){if(typeof e!="function")throw new Error("unsafeWrapper fn should be function");return function(...t){try{return e.apply(null,t)}catch{}}}const eo=ht(vt(4),dt("0123456789ABCDEF"),wt("")),no=ht(vt(5),dt("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),Qt(5),wt(""));ht(vt(5),dt("0123456789ABCDEFGHIJKLMNOPQRSTUV"),Qt(5),wt(""));ht(vt(5),dt("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),wt(""),Ln(e=>e.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const ro=ht(vt(6),dt("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),Qt(6),wt("")),oo=ht(vt(6),dt("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),Qt(6),wt("")),Te=e=>ht(to(58),dt(e),wt("")),be=Te("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");Te("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");Te("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const Ye=[0,2,3,5,6,7,9,10,11],so={encode(e){let t="";for(let n=0;n<e.length;n+=8){const r=e.subarray(n,n+8);t+=be.encode(r).padStart(Ye[r.length],"1")}return t},decode(e){let t=[];for(let n=0;n<e.length;n+=11){const r=e.slice(n,n+11),o=Ye.indexOf(r.length),s=be.decode(r);for(let i=0;i<s.length-o;i++)if(s[i]!==0)throw new Error("base58xmr: wrong padding");t=t.concat(Array.from(s.slice(s.length-o)))}return Uint8Array.from(t)}},xe=ht(dt("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),wt("")),Xe=[996825010,642813549,513874426,1027748829,705979059];function kt(e){const t=e>>25;let n=(e&33554431)<<5;for(let r=0;r<Xe.length;r++)(t>>r&1)===1&&(n^=Xe[r]);return n}function Qe(e,t,n=1){const r=e.length;let o=1;for(let s=0;s<r;s++){const i=e.charCodeAt(s);if(i<33||i>126)throw new Error(`Invalid prefix (${e})`);o=kt(o)^i>>5}o=kt(o);for(let s=0;s<r;s++)o=kt(o)^e.charCodeAt(s)&31;for(let s of t)o=kt(o)^s;for(let s=0;s<6;s++)o=kt(o);return o^=n,xe.encode(ye([o%2**30],30,5,!1))}function Hn(e){const t=e==="bech32"?1:734539939,n=vt(5),r=n.decode,o=n.encode,s=Fe(r);function i(u,l,b=90){if(typeof u!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof u}`);if(!Array.isArray(l)||l.length&&typeof l[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof l}`);const y=u.length+7+l.length;if(b!==!1&&y>b)throw new TypeError(`Length ${y} exceeds limit ${b}`);return u=u.toLowerCase(),`${u}1${xe.encode(l)}${Qe(u,l,t)}`}function c(u,l=90){if(typeof u!="string")throw new Error(`bech32.decode input should be string, not ${typeof u}`);if(u.length<8||l!==!1&&u.length>l)throw new TypeError(`Wrong string length: ${u.length} (${u}). Expected (8..${l})`);const b=u.toLowerCase();if(u!==b&&u!==u.toUpperCase())throw new Error("String must be lowercase or uppercase");u=b;const y=u.lastIndexOf("1");if(y===0||y===-1)throw new Error('Letter "1" must be present between prefix and data only');const w=u.slice(0,y),h=u.slice(y+1);if(h.length<6)throw new Error("Data must be at least 6 characters long");const d=xe.decode(h).slice(0,-6),g=Qe(w,d,t);if(!h.endsWith(g))throw new Error(`Invalid checksum in ${u}: expected "${g}"`);return{prefix:w,words:d}}const f=Fe(c);function a(u){const{prefix:l,words:b}=c(u,!1);return{prefix:l,words:b,bytes:r(b)}}return{encode:i,decode:c,decodeToBytes:a,decodeUnsafe:f,fromWords:r,fromWordsUnsafe:s,toWords:o}}const Jo=Hn("bech32");Hn("bech32m");const io={encode:e=>new TextDecoder().decode(e),decode:e=>new TextEncoder().encode(e)},co=ht(vt(4),dt("0123456789abcdef"),wt(""),Ln(e=>{if(typeof e!="string"||e.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);return e.toLowerCase()})),fo={utf8:io,hex:co,base16:eo,base32:no,base64:ro,base64url:oo,base58:be,base58xmr:so};`${Object.keys(fo).join(", ")}`;function ce(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function Je(e){if(typeof e!="boolean")throw new Error(`boolean expected, not ${e}`)}function Tn(e){return e instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"}function nt(e,...t){if(!Tn(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function Ot(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Ne(e,t){nt(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const z=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),ao=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),lo=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!lo)throw new Error("Non little-endian hardware is not supported");function _e(e){if(typeof e!="string")throw new Error(`string expected, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function Bt(e){if(typeof e=="string")e=_e(e);else if(Tn(e))e=e.slice();else throw new Error(`Uint8Array expected, got ${typeof e}`);return e}function uo(e,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(e,t)}function ts(e,t){if(e.length!==t.length)return!1;let n=0;for(let r=0;r<e.length;r++)n|=e[r]^t[r];return n===0}const ho=(e,t)=>(Object.assign(t,e),t),lt=16,Ce=new Uint8Array(16),ct=z(Ce),wo=225,go=(e,t,n,r)=>{const o=r&1;return{s3:n<<31|r>>>1,s2:t<<31|n>>>1,s1:e<<31|t>>>1,s0:e>>>1^wo<<24&-(o&1)}},et=e=>(e>>>0&255)<<24|(e>>>8&255)<<16|(e>>>16&255)<<8|e>>>24&255|0;function po(e){e.reverse();const t=e[15]&1;let n=0;for(let r=0;r<e.length;r++){const o=e[r];e[r]=o>>>1|n,n=(o&1)<<7}return e[0]^=-t&225,e}const yo=e=>e>64*1024?8:e>1024?4:2;class Nn{constructor(t,n){this.blockLen=lt,this.outputLen=lt,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,t=Bt(t),nt(t,16);const r=ao(t);let o=r.getUint32(0,!1),s=r.getUint32(4,!1),i=r.getUint32(8,!1),c=r.getUint32(12,!1);const f=[];for(let w=0;w<128;w++)f.push({s0:et(o),s1:et(s),s2:et(i),s3:et(c)}),{s0:o,s1:s,s2:i,s3:c}=go(o,s,i,c);const a=yo(n||1024);if(![1,2,4,8].includes(a))throw new Error(`ghash: wrong window size=${a}, should be 2, 4 or 8`);this.W=a;const l=128/a,b=this.windowSize=2**a,y=[];for(let w=0;w<l;w++)for(let h=0;h<b;h++){let d=0,g=0,A=0,I=0;for(let H=0;H<a;H++){if(!(h>>>a-H-1&1))continue;const{s0:m,s1:B,s2:$,s3:_}=f[a*w+H];d^=m,g^=B,A^=$,I^=_}y.push({s0:d,s1:g,s2:A,s3:I})}this.t=y}_updateBlock(t,n,r,o){t^=this.s0,n^=this.s1,r^=this.s2,o^=this.s3;const{W:s,t:i,windowSize:c}=this;let f=0,a=0,u=0,l=0;const b=(1<<s)-1;let y=0;for(const w of[t,n,r,o])for(let h=0;h<4;h++){const d=w>>>8*h&255;for(let g=8/s-1;g>=0;g--){const A=d>>>s*g&b,{s0:I,s1:H,s2:T,s3:m}=i[y*c+A];f^=I,a^=H,u^=T,l^=m,y+=1}}this.s0=f,this.s1=a,this.s2=u,this.s3=l}update(t){t=Bt(t),Ot(this);const n=z(t),r=Math.floor(t.length/lt),o=t.length%lt;for(let s=0;s<r;s++)this._updateBlock(n[s*4+0],n[s*4+1],n[s*4+2],n[s*4+3]);return o&&(Ce.set(t.subarray(r*lt)),this._updateBlock(ct[0],ct[1],ct[2],ct[3]),ct.fill(0)),this}destroy(){const{t}=this;for(const n of t)n.s0=0,n.s1=0,n.s2=0,n.s3=0}digestInto(t){Ot(this),Ne(t,this),this.finished=!0;const{s0:n,s1:r,s2:o,s3:s}=this,i=z(t);return i[0]=n,i[1]=r,i[2]=o,i[3]=s,t}digest(){const t=new Uint8Array(lt);return this.digestInto(t),this.destroy(),t}}class bo extends Nn{constructor(t,n){t=Bt(t);const r=po(t.slice());super(r,n),r.fill(0)}update(t){t=Bt(t),Ot(this);const n=z(t),r=t.length%lt,o=Math.floor(t.length/lt);for(let s=0;s<o;s++)this._updateBlock(et(n[s*4+3]),et(n[s*4+2]),et(n[s*4+1]),et(n[s*4+0]));return r&&(Ce.set(t.subarray(o*lt)),this._updateBlock(et(ct[3]),et(ct[2]),et(ct[1]),et(ct[0])),ct.fill(0)),this}digestInto(t){Ot(this),Ne(t,this),this.finished=!0;const{s0:n,s1:r,s2:o,s3:s}=this,i=z(t);return i[0]=n,i[1]=r,i[2]=o,i[3]=s,t.reverse()}}function _n(e){const t=(r,o)=>e(o,r.length).update(Bt(r)).digest(),n=e(new Uint8Array(16),0);return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=(r,o)=>e(r,o),t}_n((e,t)=>new Nn(e,t));_n((e,t)=>new bo(e,t));const mt=16,xo=283;function Oe(e){return e<<1^xo&-(e>>7)}function Nt(e,t){let n=0;for(;t>0;t>>=1)n^=e&-(t&1),e=Oe(e);return n}const Ee=(()=>{let e=new Uint8Array(256);for(let n=0,r=1;n<256;n++,r^=Oe(r))e[n]=r;const t=new Uint8Array(256);t[0]=99;for(let n=0;n<255;n++){let r=e[255-n];r|=r<<8,t[e[n]]=(r^r>>4^r>>5^r>>6^r>>7^99)&255}return t})(),Eo=Ee.map((e,t)=>Ee.indexOf(t)),mo=e=>e<<24|e>>>8,fe=e=>e<<8|e>>>24;function Cn(e,t){if(e.length!==256)throw new Error("Wrong sbox length");const n=new Uint32Array(256).map((a,u)=>t(e[u])),r=n.map(fe),o=r.map(fe),s=o.map(fe),i=new Uint32Array(256*256),c=new Uint32Array(256*256),f=new Uint16Array(256*256);for(let a=0;a<256;a++)for(let u=0;u<256;u++){const l=a*256+u;i[l]=n[a]^r[u],c[l]=o[a]^s[u],f[l]=e[a]<<8|e[u]}return{sbox:e,sbox2:f,T0:n,T1:r,T2:o,T3:s,T01:i,T23:c}}const Re=Cn(Ee,e=>Nt(e,3)<<24|e<<16|e<<8|Nt(e,2)),On=Cn(Eo,e=>Nt(e,11)<<24|Nt(e,13)<<16|Nt(e,9)<<8|Nt(e,14)),Ao=(()=>{const e=new Uint8Array(16);for(let t=0,n=1;t<16;t++,n=Oe(n))e[t]=n;return e})();function Rn(e){nt(e);const t=e.length;if(![16,24,32].includes(t))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t}`);const{sbox2:n}=Re,r=z(e),o=r.length,s=c=>at(n,c,c,c,c),i=new Uint32Array(t+28);i.set(r);for(let c=o;c<i.length;c++){let f=i[c-1];c%o===0?f=s(mo(f))^Ao[c/o-1]:o>6&&c%o===4&&(f=s(f)),i[c]=i[c-o]^f}return i}function Bo(e){const t=Rn(e),n=t.slice(),r=t.length,{sbox2:o}=Re,{T0:s,T1:i,T2:c,T3:f}=On;for(let a=0;a<r;a+=4)for(let u=0;u<4;u++)n[a+u]=t[r-a-4+u];t.fill(0);for(let a=4;a<r-4;a++){const u=n[a],l=at(o,u,u,u,u);n[a]=s[l&255]^i[l>>>8&255]^c[l>>>16&255]^f[l>>>24]}return n}function Et(e,t,n,r,o,s){return e[n<<8&65280|r>>>8&255]^t[o>>>8&65280|s>>>24&255]}function at(e,t,n,r,o){return e[t&255|n&65280]|e[r>>>16&255|o>>>16&65280]<<16}function tn(e,t,n,r,o){const{sbox2:s,T01:i,T23:c}=Re;let f=0;t^=e[f++],n^=e[f++],r^=e[f++],o^=e[f++];const a=e.length/4-2;for(let w=0;w<a;w++){const h=e[f++]^Et(i,c,t,n,r,o),d=e[f++]^Et(i,c,n,r,o,t),g=e[f++]^Et(i,c,r,o,t,n),A=e[f++]^Et(i,c,o,t,n,r);t=h,n=d,r=g,o=A}const u=e[f++]^at(s,t,n,r,o),l=e[f++]^at(s,n,r,o,t),b=e[f++]^at(s,r,o,t,n),y=e[f++]^at(s,o,t,n,r);return{s0:u,s1:l,s2:b,s3:y}}function vo(e,t,n,r,o){const{sbox2:s,T01:i,T23:c}=On;let f=0;t^=e[f++],n^=e[f++],r^=e[f++],o^=e[f++];const a=e.length/4-2;for(let w=0;w<a;w++){const h=e[f++]^Et(i,c,t,o,r,n),d=e[f++]^Et(i,c,n,t,o,r),g=e[f++]^Et(i,c,r,n,t,o),A=e[f++]^Et(i,c,o,r,n,t);t=h,n=d,r=g,o=A}const u=e[f++]^at(s,t,o,r,n),l=e[f++]^at(s,n,t,o,r),b=e[f++]^at(s,r,n,t,o),y=e[f++]^at(s,o,r,n,t);return{s0:u,s1:l,s2:b,s3:y}}function qn(e,t){if(!t)return new Uint8Array(e);if(nt(t),t.length<e)throw new Error(`aes: wrong destination length, expected at least ${e}, got: ${t.length}`);return t}function $o(e){if(nt(e),e.length%mt!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${mt}`)}function Io(e,t,n){let r=e.length;const o=r%mt;if(!t&&o!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const s=z(e);if(t){let f=mt-o;f||(f=mt),r=r+f}const i=qn(r,n),c=z(i);return{b:s,o:c,out:i}}function Uo(e,t){if(!t)return e;const n=e.length;if(!n)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=e[n-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const o=e.subarray(0,-r);for(let s=0;s<r;s++)if(e[n-s-1]!==r)throw new Error("aes/pcks5: wrong padding");return o}function Lo(e){const t=new Uint8Array(16),n=z(t);t.set(e);const r=mt-e.length;for(let o=mt-r;o<mt;o++)t[o]=r;return n}const es=ho({blockSize:16,nonceLength:16},function(t,n,r={}){nt(t),nt(n,16);const o=!r.disablePadding;return{encrypt:(s,i)=>{const c=Rn(t),{b:f,o:a,out:u}=Io(s,o,i),l=z(n);let b=l[0],y=l[1],w=l[2],h=l[3],d=0;for(;d+4<=f.length;)b^=f[d+0],y^=f[d+1],w^=f[d+2],h^=f[d+3],{s0:b,s1:y,s2:w,s3:h}=tn(c,b,y,w,h),a[d++]=b,a[d++]=y,a[d++]=w,a[d++]=h;if(o){const g=Lo(s.subarray(d*4));b^=g[0],y^=g[1],w^=g[2],h^=g[3],{s0:b,s1:y,s2:w,s3:h}=tn(c,b,y,w,h),a[d++]=b,a[d++]=y,a[d++]=w,a[d++]=h}return c.fill(0),u},decrypt:(s,i)=>{$o(s);const c=Bo(t),f=z(n),a=qn(s.length,i),u=z(s),l=z(a);let b=f[0],y=f[1],w=f[2],h=f[3];for(let d=0;d+4<=u.length;){const g=b,A=y,I=w,H=h;b=u[d+0],y=u[d+1],w=u[d+2],h=u[d+3];const{s0:T,s1:m,s2:B,s3:$}=vo(c,b,y,w,h);l[d++]=T^g,l[d++]=m^A,l[d++]=B^I,l[d++]=$^H}return c.fill(0),Uo(a,o)}}}),Z=(e,t)=>e[t++]&255|(e[t++]&255)<<8;class So{constructor(t){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,t=Bt(t),nt(t,32);const n=Z(t,0),r=Z(t,2),o=Z(t,4),s=Z(t,6),i=Z(t,8),c=Z(t,10),f=Z(t,12),a=Z(t,14);this.r[0]=n&8191,this.r[1]=(n>>>13|r<<3)&8191,this.r[2]=(r>>>10|o<<6)&7939,this.r[3]=(o>>>7|s<<9)&8191,this.r[4]=(s>>>4|i<<12)&255,this.r[5]=i>>>1&8190,this.r[6]=(i>>>14|c<<2)&8191,this.r[7]=(c>>>11|f<<5)&8065,this.r[8]=(f>>>8|a<<8)&8191,this.r[9]=a>>>5&127;for(let u=0;u<8;u++)this.pad[u]=Z(t,16+2*u)}process(t,n,r=!1){const o=r?0:2048,{h:s,r:i}=this,c=i[0],f=i[1],a=i[2],u=i[3],l=i[4],b=i[5],y=i[6],w=i[7],h=i[8],d=i[9],g=Z(t,n+0),A=Z(t,n+2),I=Z(t,n+4),H=Z(t,n+6),T=Z(t,n+8),m=Z(t,n+10),B=Z(t,n+12),$=Z(t,n+14);let _=s[0]+(g&8191),S=s[1]+((g>>>13|A<<3)&8191),U=s[2]+((A>>>10|I<<6)&8191),C=s[3]+((I>>>7|H<<9)&8191),O=s[4]+((H>>>4|T<<12)&8191),k=s[5]+(T>>>1&8191),p=s[6]+((T>>>14|m<<2)&8191),x=s[7]+((m>>>11|B<<5)&8191),v=s[8]+((B>>>8|$<<8)&8191),L=s[9]+($>>>5|o),E=0,N=E+_*c+S*(5*d)+U*(5*h)+C*(5*w)+O*(5*y);E=N>>>13,N&=8191,N+=k*(5*b)+p*(5*l)+x*(5*u)+v*(5*a)+L*(5*f),E+=N>>>13,N&=8191;let q=E+_*f+S*c+U*(5*d)+C*(5*h)+O*(5*w);E=q>>>13,q&=8191,q+=k*(5*y)+p*(5*b)+x*(5*l)+v*(5*u)+L*(5*a),E+=q>>>13,q&=8191;let R=E+_*a+S*f+U*c+C*(5*d)+O*(5*h);E=R>>>13,R&=8191,R+=k*(5*w)+p*(5*y)+x*(5*b)+v*(5*l)+L*(5*u),E+=R>>>13,R&=8191;let V=E+_*u+S*a+U*f+C*c+O*(5*d);E=V>>>13,V&=8191,V+=k*(5*h)+p*(5*w)+x*(5*y)+v*(5*b)+L*(5*l),E+=V>>>13,V&=8191;let W=E+_*l+S*u+U*a+C*f+O*c;E=W>>>13,W&=8191,W+=k*(5*d)+p*(5*h)+x*(5*w)+v*(5*y)+L*(5*b),E+=W>>>13,W&=8191;let X=E+_*b+S*l+U*u+C*a+O*f;E=X>>>13,X&=8191,X+=k*c+p*(5*d)+x*(5*h)+v*(5*w)+L*(5*y),E+=X>>>13,X&=8191;let Q=E+_*y+S*b+U*l+C*u+O*a;E=Q>>>13,Q&=8191,Q+=k*f+p*c+x*(5*d)+v*(5*h)+L*(5*w),E+=Q>>>13,Q&=8191;let G=E+_*w+S*y+U*b+C*l+O*u;E=G>>>13,G&=8191,G+=k*a+p*f+x*c+v*(5*d)+L*(5*h),E+=G>>>13,G&=8191;let ot=E+_*h+S*w+U*y+C*b+O*l;E=ot>>>13,ot&=8191,ot+=k*u+p*a+x*f+v*c+L*(5*d),E+=ot>>>13,ot&=8191;let F=E+_*d+S*h+U*w+C*y+O*b;E=F>>>13,F&=8191,F+=k*l+p*u+x*a+v*f+L*c,E+=F>>>13,F&=8191,E=(E<<2)+E|0,E=E+N|0,N=E&8191,E=E>>>13,q+=E,s[0]=N,s[1]=q,s[2]=R,s[3]=V,s[4]=W,s[5]=X,s[6]=Q,s[7]=G,s[8]=ot,s[9]=F}finalize(){const{h:t,pad:n}=this,r=new Uint16Array(10);let o=t[1]>>>13;t[1]&=8191;for(let c=2;c<10;c++)t[c]+=o,o=t[c]>>>13,t[c]&=8191;t[0]+=o*5,o=t[0]>>>13,t[0]&=8191,t[1]+=o,o=t[1]>>>13,t[1]&=8191,t[2]+=o,r[0]=t[0]+5,o=r[0]>>>13,r[0]&=8191;for(let c=1;c<10;c++)r[c]=t[c]+o,o=r[c]>>>13,r[c]&=8191;r[9]-=8192;let s=(o^1)-1;for(let c=0;c<10;c++)r[c]&=s;s=~s;for(let c=0;c<10;c++)t[c]=t[c]&s|r[c];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let i=t[0]+n[0];t[0]=i&65535;for(let c=1;c<8;c++)i=(t[c]+n[c]|0)+(i>>>16)|0,t[c]=i&65535}update(t){Ot(this);const{buffer:n,blockLen:r}=this;t=Bt(t);const o=t.length;for(let s=0;s<o;){const i=Math.min(r-this.pos,o-s);if(i===r){for(;r<=o-s;s+=r)this.process(t,s);continue}n.set(t.subarray(s,s+i),this.pos),this.pos+=i,s+=i,this.pos===r&&(this.process(n,0,!1),this.pos=0)}return this}destroy(){this.h.fill(0),this.r.fill(0),this.buffer.fill(0),this.pad.fill(0)}digestInto(t){Ot(this),Ne(t,this),this.finished=!0;const{buffer:n,h:r}=this;let{pos:o}=this;if(o){for(n[o++]=1;o<16;o++)n[o]=0;this.process(n,0,!0)}this.finalize();let s=0;for(let i=0;i<8;i++)t[s++]=r[i]>>>0,t[s++]=r[i]>>>8;return t}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}}function Ho(e){const t=(r,o)=>e(o).update(Bt(r)).digest(),n=e(new Uint8Array(32));return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=r=>e(r),t}Ho(e=>new So(e));const To=_e("expand 16-byte k"),No=_e("expand 32-byte k"),_o=z(To),Co=z(No);function j(e,t){return e<<t|e>>>32-t}function me(e){return e.byteOffset%4===0}const Vt=64,Oo=16,kn=2**32-1,en=new Uint32Array;function Ro(e,t,n,r,o,s,i,c){const f=o.length,a=new Uint8Array(Vt),u=z(a),l=me(o)&&me(s),b=l?z(o):en,y=l?z(s):en;for(let w=0;w<f;i++){if(e(t,n,r,u,i,c),i>=kn)throw new Error("arx: counter overflow");const h=Math.min(Vt,f-w);if(l&&h===Vt){const d=w/4;if(w%4!==0)throw new Error("arx: invalid block position");for(let g=0,A;g<Oo;g++)A=d+g,y[A]=b[A]^u[g];w+=Vt;continue}for(let d=0,g;d<h;d++)g=w+d,s[g]=o[g]^a[d];w+=h}}function qo(e,t){const{allowShortKeys:n,extendNonceFn:r,counterLength:o,counterRight:s,rounds:i}=uo({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof e!="function")throw new Error("core must be a function");return ce(o),ce(i),Je(s),Je(n),(c,f,a,u,l=0)=>{nt(c),nt(f),nt(a);const b=a.length;if(u||(u=new Uint8Array(b)),nt(u),ce(l),l<0||l>=kn)throw new Error("arx: counter overflow");if(u.length<b)throw new Error(`arx: output (${u.length}) is shorter than data (${b})`);const y=[];let w=c.length,h,d;if(w===32)h=c.slice(),y.push(h),d=Co;else if(w===16&&n)h=new Uint8Array(32),h.set(c),h.set(c,16),d=_o,y.push(h);else throw new Error(`arx: invalid 32-byte key, got length=${w}`);me(f)||(f=f.slice(),y.push(f));const g=z(h);if(r){if(f.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(d,g,z(f.subarray(0,16)),g),f=f.subarray(16)}const A=16-o;if(A!==f.length)throw new Error(`arx: nonce must be ${A} or 16 bytes`);if(A!==12){const H=new Uint8Array(12);H.set(f,s?0:12-f.length),f=H,y.push(f)}const I=z(f);for(Ro(e,d,g,I,a,u,l,i);y.length>0;)y.pop().fill(0);return u}}function ko(e,t,n,r,o,s=20){let i=e[0],c=e[1],f=e[2],a=e[3],u=t[0],l=t[1],b=t[2],y=t[3],w=t[4],h=t[5],d=t[6],g=t[7],A=o,I=n[0],H=n[1],T=n[2],m=i,B=c,$=f,_=a,S=u,U=l,C=b,O=y,k=w,p=h,x=d,v=g,L=A,E=I,N=H,q=T;for(let V=0;V<s;V+=2)m=m+S|0,L=j(L^m,16),k=k+L|0,S=j(S^k,12),m=m+S|0,L=j(L^m,8),k=k+L|0,S=j(S^k,7),B=B+U|0,E=j(E^B,16),p=p+E|0,U=j(U^p,12),B=B+U|0,E=j(E^B,8),p=p+E|0,U=j(U^p,7),$=$+C|0,N=j(N^$,16),x=x+N|0,C=j(C^x,12),$=$+C|0,N=j(N^$,8),x=x+N|0,C=j(C^x,7),_=_+O|0,q=j(q^_,16),v=v+q|0,O=j(O^v,12),_=_+O|0,q=j(q^_,8),v=v+q|0,O=j(O^v,7),m=m+U|0,q=j(q^m,16),x=x+q|0,U=j(U^x,12),m=m+U|0,q=j(q^m,8),x=x+q|0,U=j(U^x,7),B=B+C|0,L=j(L^B,16),v=v+L|0,C=j(C^v,12),B=B+C|0,L=j(L^B,8),v=v+L|0,C=j(C^v,7),$=$+O|0,E=j(E^$,16),k=k+E|0,O=j(O^k,12),$=$+O|0,E=j(E^$,8),k=k+E|0,O=j(O^k,7),_=_+S|0,N=j(N^_,16),p=p+N|0,S=j(S^p,12),_=_+S|0,N=j(N^_,8),p=p+N|0,S=j(S^p,7);let R=0;r[R++]=i+m|0,r[R++]=c+B|0,r[R++]=f+$|0,r[R++]=a+_|0,r[R++]=u+S|0,r[R++]=l+U|0,r[R++]=b+C|0,r[R++]=y+O|0,r[R++]=w+k|0,r[R++]=h+p|0,r[R++]=d+x|0,r[R++]=g+v|0,r[R++]=A+L|0,r[R++]=I+E|0,r[R++]=H+N|0,r[R++]=T+q|0}const ns=qo(ko,{counterRight:!1,counterLength:4,allowShortKeys:!1});class jn extends vn{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,ft.hash(t);const r=Pt(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),s.fill(0)}update(t){return ft.exists(this),this.iHash.update(t),this}digestInto(t){ft.exists(this),ft.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=c,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const qe=(e,t,n)=>new jn(e,t).update(n).digest();qe.create=(e,t)=>new jn(e,t);function rs(e,t,n){return ft.hash(e),n===void 0&&(n=new Uint8Array(e.outputLen)),qe(e,Pt(n),Pt(t))}const ae=new Uint8Array([0]),nn=new Uint8Array;function os(e,t,n,r=32){if(ft.hash(e),ft.number(r),r>255*e.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(r/e.outputLen);n===void 0&&(n=nn);const s=new Uint8Array(o*e.outputLen),i=qe.create(e,t),c=i._cloneInto(),f=new Uint8Array(i.outputLen);for(let a=0;a<o;a++)ae[0]=a+1,c.update(a===0?nn:f).update(n).update(ae).digestInto(f),s.set(f,e.outputLen*a),i._cloneInto(c);return i.destroy(),c.destroy(),f.fill(0),ae.fill(0),s.slice(0,r)}export{zo as N,Go as a,Jo as b,Yo as c,es as d,ro as e,Qo as f,Wo as g,Fo as h,rs as i,os as j,qe as k,ns as l,ts as m,Xo as r,Ue as s,Kr as u};
