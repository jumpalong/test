import{a as st}from"./nostr.5da3da54.js";import{g as it,s as ct}from"./error.32f9621f.js";import{b as ot,s as ft,n as at}from"./nostr.1ed837f5.js";import{g as ut}from"./createEventSourceTracers.70279edb.js";import{o as lt,n as dt}from"./use.1e6bcf04.js";import{u as ht}from"./Markdown.65b67b2d.js";import{f as pt,M as gt,o as wt,l as yt,w as mt,r as Et,n as q,B as xt,v as bt,x as Bt}from"./index.1b90d9b0.js";/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const h=BigInt(0),w=BigInt(1),A=BigInt(2),L=BigInt(3),_=BigInt(8),E=Object.freeze({a:h,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:w,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),j=(n,t)=>(n+t/A)/t,$={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(n){const{n:t}=E,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-w*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,f=BigInt("0x100000000000000000000000000000000"),c=j(o*n,t),u=j(-r*n,t);let a=i(n-c*e-u*s,t),p=i(-c*r-u*o,t);const g=a>f,l=p>f;if(g&&(a=t-a),l&&(p=t-p),a>f||p>f)throw new Error("splitScalarEndo: Endomorphism failed, k="+n);return{k1neg:g,k1:a,k2neg:l,k2:p}}},R=32,X=32,K=R+1,Q=2*R+1;function P(n){const{a:t,b:e}=E,r=i(n*n),s=i(r*n);return i(s+t*n+e)}const C=E.a===h;function J(n){if(!(n instanceof d))throw new TypeError("JacobianPoint expected")}class d{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof m))throw new TypeError("JacobianPoint#fromAffine: expected Point");return t.equals(m.ZERO)?d.ZERO:new d(t.x,t.y,w)}static toAffineBatch(t){const e=Ht(t.map(r=>r.z));return t.map((r,s)=>r.toAffine(e[s]))}static normalizeZ(t){return d.toAffineBatch(t).map(d.fromAffine)}equals(t){J(t);const{x:e,y:r,z:s}=this,{x:o,y:f,z:c}=t,u=i(s*s),a=i(c*c),p=i(e*a),g=i(o*u),l=i(i(r*c)*a),x=i(i(f*s)*u);return p===g&&l===x}negate(){return new d(this.x,i(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,s=i(t*t),o=i(e*e),f=i(o*o),c=t+o,u=i(A*(i(c*c)-s-f)),a=i(L*s),p=i(a*a),g=i(p-A*u),l=i(a*(u-g)-_*f),x=i(A*e*r);return new d(g,l,x)}add(t){J(t);const{x:e,y:r,z:s}=this,{x:o,y:f,z:c}=t;if(o===h||f===h)return this;if(e===h||r===h)return t;const u=i(s*s),a=i(c*c),p=i(e*a),g=i(o*u),l=i(i(r*c)*a),x=i(i(f*s)*u),y=i(g-p),B=i(x-l);if(y===h)return B===h?this.double():d.ZERO;const v=i(y*y),S=i(y*v),H=i(p*v),T=i(B*B-S-A*H),W=i(B*(H-T)-l*S),z=i(s*c*y);return new d(T,W,z)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=d.ZERO;if(typeof t=="bigint"&&t===h)return e;let r=rt(t);if(r===w)return this;if(!C){let g=e,l=this;for(;r>h;)r&w&&(g=g.add(l)),l=l.double(),r>>=w;return g}let{k1neg:s,k1:o,k2neg:f,k2:c}=$.splitScalar(r),u=e,a=e,p=this;for(;o>h||c>h;)o&w&&(u=u.add(p)),c&w&&(a=a.add(p)),p=p.double(),o>>=w,c>>=w;return s&&(u=u.negate()),f&&(a=a.negate()),a=new d(i(a.x*$.beta),a.y,a.z),u.add(a)}precomputeWindow(t){const e=C?128/t+1:256/t+1,r=[];let s=this,o=s;for(let f=0;f<e;f++){o=s,r.push(o);for(let c=1;c<2**(t-1);c++)o=o.add(s),r.push(o);s=o.double()}return r}wNAF(t,e){!e&&this.equals(d.BASE)&&(e=m.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let s=e&&M.get(e);s||(s=this.precomputeWindow(r),e&&r!==1&&(s=d.normalizeZ(s),M.set(e,s)));let o=d.ZERO,f=d.BASE;const c=1+(C?128/r:256/r),u=2**(r-1),a=BigInt(2**r-1),p=2**r,g=BigInt(r);for(let l=0;l<c;l++){const x=l*u;let y=Number(t&a);t>>=g,y>u&&(y-=p,t+=w);const B=x,v=x+Math.abs(y)-1,S=l%2!==0,H=y<0;y===0?f=f.add(D(S,s[B])):o=o.add(D(H,s[v]))}return{p:o,f}}multiply(t,e){let r=rt(t),s,o;if(C){const{k1neg:f,k1:c,k2neg:u,k2:a}=$.splitScalar(r);let{p,f:g}=this.wNAF(c,e),{p:l,f:x}=this.wNAF(a,e);p=D(f,p),l=D(u,l),l=new d(i(l.x*$.beta),l.y,l.z),s=p.add(l),o=g.add(x)}else{const{p:f,f:c}=this.wNAF(r,e);s=f,o=c}return d.normalizeZ([s,o])[0]}toAffine(t){const{x:e,y:r,z:s}=this,o=this.equals(d.ZERO);t==null&&(t=o?_:G(s));const f=t,c=i(f*f),u=i(c*f),a=i(e*c),p=i(r*u),g=i(s*f);if(o)return m.ZERO;if(g!==w)throw new Error("invZ was invalid");return new m(a,p)}}d.BASE=new d(E.Gx,E.Gy,w);d.ZERO=new d(h,w,h);function D(n,t){const e=t.negate();return n?e:t}const M=new WeakMap;class m{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,M.delete(this)}hasEvenY(){return this.y%A===h}static fromCompressedHex(t){const e=t.length===32,r=Z(e?t:t.subarray(1));if(!Y(r))throw new Error("Point is not on curve");const s=P(r);let o=St(s);const f=(o&w)===w;e?f&&(o=i(-o)):(t[0]&1)===1!==f&&(o=i(-o));const c=new m(r,o);return c.assertValidity(),c}static fromUncompressedHex(t){const e=Z(t.subarray(1,R+1)),r=Z(t.subarray(R+1,R*2+1)),s=new m(e,r);return s.assertValidity(),s}static fromHex(t){const e=nt(t),r=e.length,s=e[0];if(r===R)return this.fromCompressedHex(e);if(r===K&&(s===2||s===3))return this.fromCompressedHex(e);if(r===Q&&s===4)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-${K} compressed bytes or ${Q} uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return m.BASE.multiply(zt(t))}static fromSignature(t,e,r){const{r:s,s:o}=Ot(e);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");const f=Zt(nt(t)),{n:c}=E,u=r===2||r===3?s+c:s,a=G(u,c),p=i(-f*a,c),g=i(o*a,c),l=r&1?"03":"02",x=m.fromHex(l+N(u)),y=m.BASE.multiplyAndAddUnsafe(x,p,g);if(!y)throw new Error("Cannot recover signature: point at infinify");return y.assertValidity(),y}toRawBytes(t=!1){return k(this.toHex(t))}toHex(t=!1){const e=N(this.x);return t?`${this.hasEvenY()?"02":"03"}${e}`:`04${e}${N(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:r}=this;if(!Y(e)||!Y(r))throw new Error(t);const s=i(r*r),o=P(e);if(i(s-o)!==h)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new m(this.x,i(-this.y))}double(){return d.fromAffine(this).double().toAffine()}add(t){return d.fromAffine(this).add(d.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return d.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const s=d.fromAffine(this),o=e===h||e===w||this!==m.BASE?s.multiplyUnsafe(e):s.multiply(e),f=d.fromAffine(t).multiplyUnsafe(r),c=o.add(f);return c.equals(d.ZERO)?void 0:c.toAffine()}}m.BASE=new m(E.Gx,E.Gy);m.ZERO=new m(h,h);function tt(n){return Number.parseInt(n[0],16)>=8?"00"+n:n}function et(n){if(n.length<2||n[0]!==2)throw new Error(`Invalid signature integer tag: ${U(n)}`);const t=n[1],e=n.subarray(2,t+2);if(!t||e.length!==t)throw new Error("Invalid signature integer: wrong length");if(e[0]===0&&e[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:Z(e),left:n.subarray(t+2)}}function At(n){if(n.length<2||n[0]!=48)throw new Error(`Invalid signature tag: ${U(n)}`);if(n[1]!==n.length-2)throw new Error("Invalid signature: incorrect length");const{data:t,left:e}=et(n.subarray(2)),{data:r,left:s}=et(e);if(s.length)throw new Error(`Invalid signature: left bytes after parsing: ${U(s)}`);return{r:t,s:r}}class I{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,r="Signature.fromCompact";if(typeof t!="string"&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const s=e?U(t):t;if(s.length!==128)throw new Error(`${r}: Expected 64-byte hex`);return new I(F(s.slice(0,64)),F(s.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if(typeof t!="string"&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r,s}=At(e?t:k(t));return new I(r,s)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!V(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!V(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=E.n>>w;return this.s>t}normalizeS(){return this.hasHighS()?new I(this.r,i(-this.s,E.n)):this}toDERRawBytes(){return k(this.toDERHex())}toDERHex(){const t=tt(O(this.s)),e=tt(O(this.r)),r=t.length/2,s=e.length/2,o=O(r),f=O(s);return`30${O(s+r+4)}02${f}${e}02${o}${t}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return k(this.toCompactHex())}toCompactHex(){return N(this.r)+N(this.s)}}const It=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function U(n){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");let t="";for(let e=0;e<n.length;e++)t+=It[n[e]];return t}const vt=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function N(n){if(typeof n!="bigint")throw new Error("Expected bigint");if(!(h<=n&&n<vt))throw new Error("Expected number 0 <= n < 2^256");return n.toString(16).padStart(64,"0")}function O(n){const t=n.toString(16);return t.length&1?`0${t}`:t}function F(n){if(typeof n!="string")throw new TypeError("hexToNumber: expected string, got "+typeof n);return BigInt(`0x${n}`)}function k(n){if(typeof n!="string")throw new TypeError("hexToBytes: expected string, got "+typeof n);if(n.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+n.length);const t=new Uint8Array(n.length/2);for(let e=0;e<t.length;e++){const r=e*2,s=n.slice(r,r+2),o=Number.parseInt(s,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");t[e]=o}return t}function Z(n){return F(U(n))}function nt(n){return n instanceof Uint8Array?Uint8Array.from(n):k(n)}function rt(n){if(typeof n=="number"&&Number.isSafeInteger(n)&&n>0)return BigInt(n);if(typeof n=="bigint"&&V(n))return n;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function i(n,t=E.P){const e=n%t;return e>=h?e:t+e}function b(n,t){const{P:e}=E;let r=n;for(;t-- >h;)r*=r,r%=e;return r}function St(n){const{P:t}=E,e=BigInt(6),r=BigInt(11),s=BigInt(22),o=BigInt(23),f=BigInt(44),c=BigInt(88),u=n*n*n%t,a=u*u*n%t,p=b(a,L)*a%t,g=b(p,L)*a%t,l=b(g,A)*u%t,x=b(l,r)*l%t,y=b(x,s)*x%t,B=b(y,f)*y%t,v=b(B,c)*B%t,S=b(v,f)*y%t,H=b(S,L)*a%t,T=b(H,o)*x%t,W=b(T,e)*u%t,z=b(W,A);if(z*z%t!==n)throw new Error("Cannot find square root");return z}function G(n,t=E.P){if(n===h||t<=h)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=i(n,t),r=t,s=h,o=w;for(;e!==h;){const c=r/e,u=r%e,a=s-o*c;r=e,e=u,s=o,o=a}if(r!==w)throw new Error("invert: does not exist");return i(s,t)}function Ht(n,t=E.P){const e=new Array(n.length),r=n.reduce((o,f,c)=>f===h?o:(e[c]=o,i(o*f,t)),w),s=G(r,t);return n.reduceRight((o,f,c)=>f===h?o:(e[c]=i(o*e[c],t),i(o*f,t)),s),e}function Rt(n){const t=n.length*8-X*8,e=Z(n);return t>0?e>>BigInt(t):e}function Zt(n,t=!1){const e=Rt(n);if(t)return e;const{n:r}=E;return e>=r?e-r:e}function V(n){return h<n&&n<E.n}function Y(n){return h<n&&n<E.P}function zt(n){let t;if(typeof n=="bigint")t=n;else if(typeof n=="number"&&Number.isSafeInteger(n)&&n>0)t=BigInt(n);else if(typeof n=="string"){if(n.length!==2*X)throw new Error("Expected 32 bytes of private key");t=F(n)}else if(n instanceof Uint8Array){if(n.length!==X)throw new Error("Expected 32 bytes of private key");t=Z(n)}else throw new TypeError("Expected valid private key");if(!V(t))throw new Error("Expected private key: 0 < key < n");return t}function Ot(n){if(n instanceof I)return n.assertValidity(),n;try{return I.fromDER(n)}catch{return I.fromCompact(n)}}m.BASE._setWindowSize(8);async function Ft(n,t){var s;const e=await it({intercept:!0});let r=Object.assign(st(n),{pubkey:e});return r=JSON.parse(JSON.stringify(r)),r.id=ot(r),r=await ct(r,{intercept:(s=t==null?void 0:t.intercept)!=null?s:!0}),r}function Vt(n,t){let e=Object.assign(st(n));return e.id=ot(e),e.sig=ft(e,t),e}function Wt(n){const t=lt("d",n.tags);if(!(t&&t[1]))return;const e=dt(n.tags),r=ut(n.id);return at.naddrEncode({identifier:t[1],pubkey:n.pubkey,kind:n.kind,relays:[...e,...r!=null?r:[]]})}const qt=pt({__name:"NaddrLink",props:{addr:null},setup(n){const e=gt(n,"addr"),{event:r,longFormContentOptions:s}=ht(e);return(o,f)=>{const c=xt("RouterLink");return wt(),yt(c,{to:{name:"article",params:{value:q(e)}}},{default:mt(()=>[Et(o.$slots,"default",{},()=>{var u,a;return[bt(Bt((a=(u=q(s))==null?void 0:u.title)!=null?a:q(e)),1)]})]),_:3},8,["to"])}}});export{qt as _,Wt as a,Ft as b,Vt as c};
