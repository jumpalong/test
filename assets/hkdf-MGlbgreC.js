var Io=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Uo(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function vo(e){if(e.__esModule)return e;var t=e.default;if(typeof t=="function"){var n=function r(){return this instanceof r?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};n.prototype=t.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(e).forEach(function(r){var o=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(n,r,o.get?o:{enumerable:!0,get:function(){return e[r]}})}),n}function qe(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function Je(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function Cn(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");qe(e.outputLen),qe(e.blockLen)}function Pt(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Rn(e,t){Je(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const Yt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const tn=e=>e instanceof Uint8Array,Xt=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),st=(e,t)=>e<<32-t|e>>>t,qn=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!qn)throw new Error("Non little-endian hardware is not supported");function jn(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function be(e){if(typeof e=="string"&&(e=jn(e)),!tn(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}function kn(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!tn(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}let en=class{clone(){return this._cloneInto()}};function Pn(e){const t=r=>e().update(be(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function nn(e=32){if(Yt&&typeof Yt.getRandomValues=="function")return Yt.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}function Vn(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),c=Number(n&s),f=r?4:0,a=r?0:4;e.setUint32(t+f,i,r),e.setUint32(t+a,c,r)}let Kn=class extends en{constructor(t,n,r,o){super(),this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Xt(this.buffer)}update(t){Pt(this);const{view:n,buffer:r,blockLen:o}=this;t=be(t);const s=t.length;for(let i=0;i<s;){const c=Math.min(o-this.pos,s-i);if(c===o){const f=Xt(t);for(;o<=s-i;i+=o)this.process(f,i);continue}r.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Pt(this),Rn(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;n[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(r,0),i=0);for(let l=i;l<o;l++)n[l]=0;Vn(r,o-8,BigInt(this.length*8),s),this.process(r,0);const c=Xt(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)c.setUint32(4*l,u[l],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:c}=this;return t.length=o,t.pos=c,t.finished=s,t.destroyed=i,o%n&&t.buffer.set(r),t}};const zn=(e,t,n)=>e&t^~e&n,Mn=(e,t,n)=>e&t^e&n^t&n,Zn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),gt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),pt=new Uint32Array(64);let Dn=class extends Kn{constructor(){super(64,32,8,!1),this.A=gt[0]|0,this.B=gt[1]|0,this.C=gt[2]|0,this.D=gt[3]|0,this.E=gt[4]|0,this.F=gt[5]|0,this.G=gt[6]|0,this.H=gt[7]|0}get(){const{A:t,B:n,C:r,D:o,E:s,F:i,G:c,H:f}=this;return[t,n,r,o,s,i,c,f]}set(t,n,r,o,s,i,c,f){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=f|0}process(t,n){for(let l=0;l<16;l++,n+=4)pt[l]=t.getUint32(n,!1);for(let l=16;l<64;l++){const b=pt[l-15],y=pt[l-2],w=st(b,7)^st(b,18)^b>>>3,h=st(y,17)^st(y,19)^y>>>10;pt[l]=h+pt[l-7]+w+pt[l-16]|0}let{A:r,B:o,C:s,D:i,E:c,F:f,G:a,H:u}=this;for(let l=0;l<64;l++){const b=st(c,6)^st(c,11)^st(c,25),y=u+b+zn(c,f,a)+Zn[l]+pt[l]|0,h=(st(r,2)^st(r,13)^st(r,22))+Mn(r,o,s)|0;u=a,a=f,f=c,c=i+y|0,i=s,s=o,o=r,r=y+h|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(r,o,s,i,c,f,a,u)}roundClean(){pt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const ie=Pn(()=>new Dn);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const rn=BigInt(0),Zt=BigInt(1),Gn=BigInt(2),Dt=e=>e instanceof Uint8Array,Wn=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function Tt(e){if(!Dt(e))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=Wn[e[n]];return t}function on(e){const t=e.toString(16);return t.length&1?`0${t}`:t}function xe(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return BigInt(e===""?"0":`0x${e}`)}function Ot(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let r=0;r<n.length;r++){const o=r*2,s=e.slice(o,o+2),i=Number.parseInt(s,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");n[r]=i}return n}function Y(e){return xe(Tt(e))}function Ee(e){if(!Dt(e))throw new Error("Uint8Array expected");return xe(Tt(Uint8Array.from(e).reverse()))}function mt(e,t){return Ot(e.toString(16).padStart(t*2,"0"))}function me(e,t){return mt(e,t).reverse()}function Fn(e){return Ot(on(e))}function D(e,t,n){let r;if(typeof t=="string")try{r=Ot(t)}catch(s){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`)}else if(Dt(t))r=Uint8Array.from(t);else throw new Error(`${e} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${e} expected ${n} bytes, got ${o}`);return r}function Ut(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!Dt(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}function Yn(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Xn(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function Qn(e){let t;for(t=0;e>rn;e>>=Zt,t+=1);return t}function Jn(e,t){return e>>BigInt(t)&Zt}const tr=(e,t,n)=>e|(n?Zt:rn)<<BigInt(t),Ae=e=>(Gn<<BigInt(e-1))-Zt,Qt=e=>new Uint8Array(e),je=e=>Uint8Array.from(e);function sn(e,t,n){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=Qt(e),o=Qt(e),s=0;const i=()=>{r.fill(1),o.fill(0),s=0},c=(...l)=>n(o,r,...l),f=(l=Qt())=>{o=c(je([0]),l),r=c(),l.length!==0&&(o=c(je([1]),l),r=c())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const b=[];for(;l<t;){r=c();const y=r.slice();b.push(y),l+=r.length}return Ut(...b)};return(l,b)=>{i(),f(l);let y;for(;!(y=b(a()));)f();return i(),y}}const er={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||e instanceof Uint8Array,isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function jt(e,t,n={}){const r=(o,s,i)=>{const c=er[s];if(typeof c!="function")throw new Error(`Invalid validator "${s}", expected function`);const f=e[o];if(!(i&&f===void 0)&&!c(f,e))throw new Error(`Invalid param ${String(o)}=${f} (${typeof f}), expected ${s}`)};for(const[o,s]of Object.entries(t))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return e}const nr=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Jn,bitLen:Qn,bitMask:Ae,bitSet:tr,bytesToHex:Tt,bytesToNumberBE:Y,bytesToNumberLE:Ee,concatBytes:Ut,createHmacDrbg:sn,ensureBytes:D,equalBytes:Yn,hexToBytes:Ot,hexToNumber:xe,numberToBytesBE:mt,numberToBytesLE:me,numberToHexUnpadded:on,numberToVarBytesBE:Fn,utf8ToBytes:Xn,validateObject:jt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const z=BigInt(0),P=BigInt(1),$t=BigInt(2),rr=BigInt(3),ce=BigInt(4),ke=BigInt(5),Pe=BigInt(8);BigInt(9);BigInt(16);function Z(e,t){const n=e%t;return n>=z?n:t+n}function or(e,t,n){if(n<=z||t<z)throw new Error("Expected power/modulo > 0");if(n===P)return z;let r=P;for(;t>z;)t&P&&(r=r*e%n),e=e*e%n,t>>=P;return r}function J(e,t,n){let r=e;for(;t-- >z;)r*=r,r%=n;return r}function fe(e,t){if(e===z||t<=z)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let n=Z(e,t),r=t,o=z,s=P;for(;n!==z;){const c=r/n,f=r%n,a=o-s*c;r=n,n=f,o=s,s=a}if(r!==P)throw new Error("invert: does not exist");return Z(o,t)}function sr(e){const t=(e-P)/$t;let n,r,o;for(n=e-P,r=0;n%$t===z;n/=$t,r++);for(o=$t;o<e&&or(o,t,e)!==e-P;o++);if(r===1){const i=(e+P)/ce;return function(f,a){const u=f.pow(a,i);if(!f.eql(f.sqr(u),a))throw new Error("Cannot find square root");return u}}const s=(n+P)/$t;return function(c,f){if(c.pow(f,t)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,u=c.pow(c.mul(c.ONE,o),n),l=c.pow(f,s),b=c.pow(f,n);for(;!c.eql(b,c.ONE);){if(c.eql(b,c.ZERO))return c.ZERO;let y=1;for(let h=c.sqr(b);y<a&&!c.eql(h,c.ONE);y++)h=c.sqr(h);const w=c.pow(u,P<<BigInt(a-y-1));u=c.sqr(w),l=c.mul(l,w),b=c.mul(b,u),a=y}return l}}function ir(e){if(e%ce===rr){const t=(e+P)/ce;return function(r,o){const s=r.pow(o,t);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(e%Pe===ke){const t=(e-ke)/Pe;return function(r,o){const s=r.mul(o,$t),i=r.pow(s,t),c=r.mul(o,i),f=r.mul(r.mul(c,$t),i),a=r.mul(c,r.sub(f,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return sr(e)}const cr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function fr(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=cr.reduce((r,o)=>(r[o]="function",r),t);return jt(e,n)}function ar(e,t,n){if(n<z)throw new Error("Expected power > 0");if(n===z)return e.ONE;if(n===P)return t;let r=e.ONE,o=t;for(;n>z;)n&P&&(r=e.mul(r,o)),o=e.sqr(o),n>>=P;return r}function lr(e,t){const n=new Array(t.length),r=t.reduce((s,i,c)=>e.is0(i)?s:(n[c]=s,e.mul(s,i)),e.ONE),o=e.inv(r);return t.reduceRight((s,i,c)=>e.is0(i)?s:(n[c]=e.mul(s,n[c]),e.mul(s,i)),o),n}function cn(e,t){const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function ur(e,t,n=!1,r={}){if(e<=z)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:o,nByteLength:s}=cn(e,t);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=ir(e),c=Object.freeze({ORDER:e,BITS:o,BYTES:s,MASK:Ae(o),ZERO:z,ONE:P,create:f=>Z(f,e),isValid:f=>{if(typeof f!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);return z<=f&&f<e},is0:f=>f===z,isOdd:f=>(f&P)===P,neg:f=>Z(-f,e),eql:(f,a)=>f===a,sqr:f=>Z(f*f,e),add:(f,a)=>Z(f+a,e),sub:(f,a)=>Z(f-a,e),mul:(f,a)=>Z(f*a,e),pow:(f,a)=>ar(c,f,a),div:(f,a)=>Z(f*fe(a,e),e),sqrN:f=>f*f,addN:(f,a)=>f+a,subN:(f,a)=>f-a,mulN:(f,a)=>f*a,inv:f=>fe(f,e),sqrt:r.sqrt||(f=>i(c,f)),invertBatch:f=>lr(c,f),cmov:(f,a,u)=>u?a:f,toBytes:f=>n?me(f,s):mt(f,s),fromBytes:f=>{if(f.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${f.length}`);return n?Ee(f):Y(f)}});return Object.freeze(c)}function fn(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function an(e){const t=fn(e);return t+Math.ceil(t/2)}function hr(e,t,n=!1){const r=e.length,o=fn(t),s=an(t);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const i=n?Y(e):Ee(e),c=Z(i,t-P)+P;return n?me(c,o):mt(c,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const dr=BigInt(0),Jt=BigInt(1);function wr(e,t){const n=(o,s)=>{const i=s.negate();return o?i:s},r=o=>{const s=Math.ceil(t/o)+1,i=2**(o-1);return{windows:s,windowSize:i}};return{constTimeNegate:n,unsafeLadder(o,s){let i=e.ZERO,c=o;for(;s>dr;)s&Jt&&(i=i.add(c)),c=c.double(),s>>=Jt;return i},precomputeWindow(o,s){const{windows:i,windowSize:c}=r(s),f=[];let a=o,u=a;for(let l=0;l<i;l++){u=a,f.push(u);for(let b=1;b<c;b++)u=u.add(a),f.push(u);a=u.double()}return f},wNAF(o,s,i){const{windows:c,windowSize:f}=r(o);let a=e.ZERO,u=e.BASE;const l=BigInt(2**o-1),b=2**o,y=BigInt(o);for(let w=0;w<c;w++){const h=w*f;let d=Number(i&l);i>>=y,d>f&&(d-=b,i+=Jt);const g=h,A=h+Math.abs(d)-1,U=w%2!==0,H=d<0;d===0?u=u.add(n(U,s[g])):a=a.add(n(H,s[A]))}return{p:a,f:u}},wNAFCached(o,s,i,c){const f=o._WINDOW_SIZE||1;let a=s.get(o);return a||(a=this.precomputeWindow(o,f),f!==1&&s.set(o,c(a))),this.wNAF(f,a,i)}}}function ln(e){return fr(e.Fp),jt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...cn(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function gr(e){const t=ln(e);jt(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=t;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:pr,hexToBytes:yr}=nr,It={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(e){const{Err:t}=It;if(e.length<2||e[0]!==2)throw new t("Invalid signature integer tag");const n=e[1],r=e.subarray(2,n+2);if(!n||r.length!==n)throw new t("Invalid signature integer: wrong length");if(r[0]&128)throw new t("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:pr(r),l:e.subarray(n+2)}},toSig(e){const{Err:t}=It,n=typeof e=="string"?yr(e):e;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new t("Invalid signature tag");if(n[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:o,l:s}=It._parseInt(n.subarray(2)),{d:i,l:c}=It._parseInt(s);if(c.length)throw new t("Invalid signature: left bytes after parsing");return{r:o,s:i}},hexFromSig(e){const t=a=>Number.parseInt(a[0],16)&8?"00"+a:a,n=a=>{const u=a.toString(16);return u.length&1?`0${u}`:u},r=t(n(e.s)),o=t(n(e.r)),s=r.length/2,i=o.length/2,c=n(s),f=n(i);return`30${n(i+s+4)}02${f}${o}02${c}${r}`}},ut=BigInt(0),tt=BigInt(1);BigInt(2);const Ve=BigInt(3);BigInt(4);function br(e){const t=gr(e),{Fp:n}=t,r=t.toBytes||((w,h,d)=>{const g=h.toAffine();return Ut(Uint8Array.from([4]),n.toBytes(g.x),n.toBytes(g.y))}),o=t.fromBytes||(w=>{const h=w.subarray(1),d=n.fromBytes(h.subarray(0,n.BYTES)),g=n.fromBytes(h.subarray(n.BYTES,2*n.BYTES));return{x:d,y:g}});function s(w){const{a:h,b:d}=t,g=n.sqr(w),A=n.mul(g,w);return n.add(n.add(A,n.mul(w,h)),d)}if(!n.eql(n.sqr(t.Gy),s(t.Gx)))throw new Error("bad generator point: equation left != right");function i(w){return typeof w=="bigint"&&ut<w&&w<t.n}function c(w){if(!i(w))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function f(w){const{allowedPrivateKeyLengths:h,nByteLength:d,wrapPrivateKey:g,n:A}=t;if(h&&typeof w!="bigint"){if(w instanceof Uint8Array&&(w=Tt(w)),typeof w!="string"||!h.includes(w.length))throw new Error("Invalid key");w=w.padStart(d*2,"0")}let U;try{U=typeof w=="bigint"?w:Y(D("private key",w,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof w}`)}return g&&(U=Z(U,A)),c(U),U}const a=new Map;function u(w){if(!(w instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(h,d,g){if(this.px=h,this.py=d,this.pz=g,h==null||!n.isValid(h))throw new Error("x required");if(d==null||!n.isValid(d))throw new Error("y required");if(g==null||!n.isValid(g))throw new Error("z required")}static fromAffine(h){const{x:d,y:g}=h||{};if(!h||!n.isValid(d)||!n.isValid(g))throw new Error("invalid affine point");if(h instanceof l)throw new Error("projective point not allowed");const A=U=>n.eql(U,n.ZERO);return A(d)&&A(g)?l.ZERO:new l(d,g,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const d=n.invertBatch(h.map(g=>g.pz));return h.map((g,A)=>g.toAffine(d[A])).map(l.fromAffine)}static fromHex(h){const d=l.fromAffine(o(D("pointHex",h)));return d.assertValidity(),d}static fromPrivateKey(h){return l.BASE.multiply(f(h))}_setWindowSize(h){this._WINDOW_SIZE=h,a.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:h,y:d}=this.toAffine();if(!n.isValid(h)||!n.isValid(d))throw new Error("bad point: x or y not FE");const g=n.sqr(d),A=s(h);if(!n.eql(g,A))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:h}=this.toAffine();if(n.isOdd)return!n.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){u(h);const{px:d,py:g,pz:A}=this,{px:U,py:H,pz:T}=h,m=n.eql(n.mul(d,T),n.mul(U,A)),B=n.eql(n.mul(g,T),n.mul(H,A));return m&&B}negate(){return new l(this.px,n.neg(this.py),this.pz)}double(){const{a:h,b:d}=t,g=n.mul(d,Ve),{px:A,py:U,pz:H}=this;let T=n.ZERO,m=n.ZERO,B=n.ZERO,I=n.mul(A,A),N=n.mul(U,U),S=n.mul(H,H),v=n.mul(A,U);return v=n.add(v,v),B=n.mul(A,H),B=n.add(B,B),T=n.mul(h,B),m=n.mul(g,S),m=n.add(T,m),T=n.sub(N,m),m=n.add(N,m),m=n.mul(T,m),T=n.mul(v,T),B=n.mul(g,B),S=n.mul(h,S),v=n.sub(I,S),v=n.mul(h,v),v=n.add(v,B),B=n.add(I,I),I=n.add(B,I),I=n.add(I,S),I=n.mul(I,v),m=n.add(m,I),S=n.mul(U,H),S=n.add(S,S),I=n.mul(S,v),T=n.sub(T,I),B=n.mul(S,N),B=n.add(B,B),B=n.add(B,B),new l(T,m,B)}add(h){u(h);const{px:d,py:g,pz:A}=this,{px:U,py:H,pz:T}=h;let m=n.ZERO,B=n.ZERO,I=n.ZERO;const N=t.a,S=n.mul(t.b,Ve);let v=n.mul(d,U),_=n.mul(g,H),C=n.mul(A,T),j=n.add(d,g),p=n.add(U,H);j=n.mul(j,p),p=n.add(v,_),j=n.sub(j,p),p=n.add(d,A);let x=n.add(U,T);return p=n.mul(p,x),x=n.add(v,C),p=n.sub(p,x),x=n.add(g,A),m=n.add(H,T),x=n.mul(x,m),m=n.add(_,C),x=n.sub(x,m),I=n.mul(N,p),m=n.mul(S,C),I=n.add(m,I),m=n.sub(_,I),I=n.add(_,I),B=n.mul(m,I),_=n.add(v,v),_=n.add(_,v),C=n.mul(N,C),p=n.mul(S,p),_=n.add(_,C),C=n.sub(v,C),C=n.mul(N,C),p=n.add(p,C),v=n.mul(_,p),B=n.add(B,v),v=n.mul(x,p),m=n.mul(j,m),m=n.sub(m,v),v=n.mul(j,_),I=n.mul(x,I),I=n.add(I,v),new l(m,B,I)}subtract(h){return this.add(h.negate())}is0(){return this.equals(l.ZERO)}wNAF(h){return y.wNAFCached(this,a,h,d=>{const g=n.invertBatch(d.map(A=>A.pz));return d.map((A,U)=>A.toAffine(g[U])).map(l.fromAffine)})}multiplyUnsafe(h){const d=l.ZERO;if(h===ut)return d;if(c(h),h===tt)return this;const{endo:g}=t;if(!g)return y.unsafeLadder(this,h);let{k1neg:A,k1:U,k2neg:H,k2:T}=g.splitScalar(h),m=d,B=d,I=this;for(;U>ut||T>ut;)U&tt&&(m=m.add(I)),T&tt&&(B=B.add(I)),I=I.double(),U>>=tt,T>>=tt;return A&&(m=m.negate()),H&&(B=B.negate()),B=new l(n.mul(B.px,g.beta),B.py,B.pz),m.add(B)}multiply(h){c(h);let d=h,g,A;const{endo:U}=t;if(U){const{k1neg:H,k1:T,k2neg:m,k2:B}=U.splitScalar(d);let{p:I,f:N}=this.wNAF(T),{p:S,f:v}=this.wNAF(B);I=y.constTimeNegate(H,I),S=y.constTimeNegate(m,S),S=new l(n.mul(S.px,U.beta),S.py,S.pz),g=I.add(S),A=N.add(v)}else{const{p:H,f:T}=this.wNAF(d);g=H,A=T}return l.normalizeZ([g,A])[0]}multiplyAndAddUnsafe(h,d,g){const A=l.BASE,U=(T,m)=>m===ut||m===tt||!T.equals(A)?T.multiplyUnsafe(m):T.multiply(m),H=U(this,d).add(U(h,g));return H.is0()?void 0:H}toAffine(h){const{px:d,py:g,pz:A}=this,U=this.is0();h==null&&(h=U?n.ONE:n.inv(A));const H=n.mul(d,h),T=n.mul(g,h),m=n.mul(A,h);if(U)return{x:n.ZERO,y:n.ZERO};if(!n.eql(m,n.ONE))throw new Error("invZ was invalid");return{x:H,y:T}}isTorsionFree(){const{h,isTorsionFree:d}=t;if(h===tt)return!0;if(d)return d(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:d}=t;return h===tt?this:d?d(l,this):this.multiplyUnsafe(t.h)}toRawBytes(h=!0){return this.assertValidity(),r(l,this,h)}toHex(h=!0){return Tt(this.toRawBytes(h))}}l.BASE=new l(t.Gx,t.Gy,n.ONE),l.ZERO=new l(n.ZERO,n.ONE,n.ZERO);const b=t.nBitLength,y=wr(l,t.endo?Math.ceil(b/2):b);return{CURVE:t,ProjectivePoint:l,normPrivateKeyToScalar:f,weierstrassEquation:s,isWithinCurveOrder:i}}function xr(e){const t=ln(e);return jt(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function Er(e){const t=xr(e),{Fp:n,n:r}=t,o=n.BYTES+1,s=2*n.BYTES+1;function i(p){return ut<p&&p<n.ORDER}function c(p){return Z(p,r)}function f(p){return fe(p,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:u,weierstrassEquation:l,isWithinCurveOrder:b}=br({...t,toBytes(p,x,$){const L=x.toAffine(),E=n.toBytes(L.x),O=Ut;return $?O(Uint8Array.from([x.hasEvenY()?2:3]),E):O(Uint8Array.from([4]),E,n.toBytes(L.y))},fromBytes(p){const x=p.length,$=p[0],L=p.subarray(1);if(x===o&&($===2||$===3)){const E=Y(L);if(!i(E))throw new Error("Point is not on curve");const O=l(E);let q=n.sqrt(O);const R=(q&tt)===tt;return($&1)===1!==R&&(q=n.neg(q)),{x:E,y:q}}else if(x===s&&$===4){const E=n.fromBytes(L.subarray(0,n.BYTES)),O=n.fromBytes(L.subarray(n.BYTES,2*n.BYTES));return{x:E,y:O}}else throw new Error(`Point of length ${x} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),y=p=>Tt(mt(p,t.nByteLength));function w(p){const x=r>>tt;return p>x}function h(p){return w(p)?c(-p):p}const d=(p,x,$)=>Y(p.slice(x,$));class g{constructor(x,$,L){this.r=x,this.s=$,this.recovery=L,this.assertValidity()}static fromCompact(x){const $=t.nByteLength;return x=D("compactSignature",x,$*2),new g(d(x,0,$),d(x,$,2*$))}static fromDER(x){const{r:$,s:L}=It.toSig(D("DER",x));return new g($,L)}assertValidity(){if(!b(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!b(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(x){return new g(this.r,this.s,x)}recoverPublicKey(x){const{r:$,s:L,recovery:E}=this,O=B(D("msgHash",x));if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");const q=E===2||E===3?$+t.n:$;if(q>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const R=E&1?"03":"02",K=a.fromHex(R+y(q)),G=f(q),X=c(-O*G),Q=c(L*G),W=a.BASE.multiplyAndAddUnsafe(K,X,Q);if(!W)throw new Error("point at infinify");return W.assertValidity(),W}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Ot(this.toDERHex())}toDERHex(){return It.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Ot(this.toCompactHex())}toCompactHex(){return y(this.r)+y(this.s)}}const A={isValidPrivateKey(p){try{return u(p),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const p=an(t.n);return hr(t.randomBytes(p),t.n)},precompute(p=8,x=a.BASE){return x._setWindowSize(p),x.multiply(BigInt(3)),x}};function U(p,x=!0){return a.fromPrivateKey(p).toRawBytes(x)}function H(p){const x=p instanceof Uint8Array,$=typeof p=="string",L=(x||$)&&p.length;return x?L===o||L===s:$?L===2*o||L===2*s:p instanceof a}function T(p,x,$=!0){if(H(p))throw new Error("first arg must be private key");if(!H(x))throw new Error("second arg must be public key");return a.fromHex(x).multiply(u(p)).toRawBytes($)}const m=t.bits2int||function(p){const x=Y(p),$=p.length*8-t.nBitLength;return $>0?x>>BigInt($):x},B=t.bits2int_modN||function(p){return c(m(p))},I=Ae(t.nBitLength);function N(p){if(typeof p!="bigint")throw new Error("bigint expected");if(!(ut<=p&&p<I))throw new Error(`bigint expected < 2^${t.nBitLength}`);return mt(p,t.nByteLength)}function S(p,x,$=v){if(["recovered","canonical"].some(F=>F in $))throw new Error("sign() legacy options not supported");const{hash:L,randomBytes:E}=t;let{lowS:O,prehash:q,extraEntropy:R}=$;O==null&&(O=!0),p=D("msgHash",p),q&&(p=D("prehashed msgHash",L(p)));const K=B(p),G=u(x),X=[N(G),N(K)];if(R!=null){const F=R===!0?E(n.BYTES):R;X.push(D("extraEntropy",F))}const Q=Ut(...X),W=K;function ot(F){const vt=m(F);if(!b(vt))return;const _e=f(vt),Lt=a.BASE.multiply(vt).toAffine(),rt=c(Lt.x);if(rt===ut)return;const St=c(_e*c(W+rt*G));if(St===ut)return;let Ce=(Lt.x===rt?0:2)|Number(Lt.y&tt),Re=St;return O&&w(St)&&(Re=h(St),Ce^=1),new g(rt,Re,Ce)}return{seed:Q,k2sig:ot}}const v={lowS:t.lowS,prehash:!1},_={lowS:t.lowS,prehash:!1};function C(p,x,$=v){const{seed:L,k2sig:E}=S(p,x,$),O=t;return sn(O.hash.outputLen,O.nByteLength,O.hmac)(L,E)}a.BASE._setWindowSize(8);function j(p,x,$,L=_){var Lt;const E=p;if(x=D("msgHash",x),$=D("publicKey",$),"strict"in L)throw new Error("options.strict was renamed to lowS");const{lowS:O,prehash:q}=L;let R,K;try{if(typeof E=="string"||E instanceof Uint8Array)try{R=g.fromDER(E)}catch(rt){if(!(rt instanceof It.Err))throw rt;R=g.fromCompact(E)}else if(typeof E=="object"&&typeof E.r=="bigint"&&typeof E.s=="bigint"){const{r:rt,s:St}=E;R=new g(rt,St)}else throw new Error("PARSE");K=a.fromHex($)}catch(rt){if(rt.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(O&&R.hasHighS())return!1;q&&(x=t.hash(x));const{r:G,s:X}=R,Q=B(x),W=f(X),ot=c(Q*W),F=c(G*W),vt=(Lt=a.BASE.multiplyAndAddUnsafe(K,ot,F))==null?void 0:Lt.toAffine();return vt?c(vt.x)===G:!1}return{CURVE:t,getPublicKey:U,getSharedSecret:T,sign:C,verify:j,ProjectivePoint:a,Signature:g,utils:A}}let un=class extends en{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,Cn(t);const r=be(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),s.fill(0)}update(t){return Pt(this),this.iHash.update(t),this}digestInto(t){Pt(this),Je(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=c,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hn=(e,t,n)=>new un(e,t).update(n).digest();hn.create=(e,t)=>new un(e,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function mr(e){return{hash:e,hmac:(t,...n)=>hn(e,t,kn(...n)),randomBytes:nn}}function Ar(e,t){const n=r=>Er({...e,...mr(r)});return Object.freeze({...n(t),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Gt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Vt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),dn=BigInt(1),Kt=BigInt(2),Ke=(e,t)=>(e+t/Kt)/t;function wn(e){const t=Gt,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),c=BigInt(44),f=BigInt(88),a=e*e*e%t,u=a*a*e%t,l=J(u,n,t)*u%t,b=J(l,n,t)*u%t,y=J(b,Kt,t)*a%t,w=J(y,o,t)*y%t,h=J(w,s,t)*w%t,d=J(h,c,t)*h%t,g=J(d,f,t)*d%t,A=J(g,c,t)*h%t,U=J(A,n,t)*u%t,H=J(U,i,t)*w%t,T=J(H,r,t)*a%t,m=J(T,Kt,t);if(!ae.eql(ae.sqr(m),e))throw new Error("Cannot find square root");return m}const ae=ur(Gt,void 0,void 0,{sqrt:wn}),Be=Ar({a:BigInt(0),b:BigInt(7),Fp:ae,n:Vt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=Vt,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-dn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,i=BigInt("0x100000000000000000000000000000000"),c=Ke(s*e,t),f=Ke(-r*e,t);let a=Z(e-c*n-f*o,t),u=Z(-c*r-f*s,t);const l=a>i,b=u>i;if(l&&(a=t-a),b&&(u=t-u),a>i||u>i)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:l,k1:a,k2neg:b,k2:u}}}},ie),Wt=BigInt(0),gn=e=>typeof e=="bigint"&&Wt<e&&e<Gt,Br=e=>typeof e=="bigint"&&Wt<e&&e<Vt,ze={};function zt(e,...t){let n=ze[e];if(n===void 0){const r=ie(Uint8Array.from(e,o=>o.charCodeAt(0)));n=Ut(r,r),ze[e]=n}return ie(Ut(n,...t))}const $e=e=>e.toRawBytes(!0).slice(1),le=e=>mt(e,32),te=e=>Z(e,Gt),Rt=e=>Z(e,Vt),Ie=Be.ProjectivePoint,$r=(e,t,n)=>Ie.BASE.multiplyAndAddUnsafe(e,t,n);function ue(e){let t=Be.utils.normPrivateKeyToScalar(e),n=Ie.fromPrivateKey(t);return{scalar:n.hasEvenY()?t:Rt(-t),bytes:$e(n)}}function pn(e){if(!gn(e))throw new Error("bad x: need 0 < x < p");const t=te(e*e),n=te(t*e+BigInt(7));let r=wn(n);r%Kt!==Wt&&(r=te(-r));const o=new Ie(e,r,dn);return o.assertValidity(),o}function yn(...e){return Rt(Y(zt("BIP0340/challenge",...e)))}function Ir(e){return ue(e).bytes}function Ur(e,t,n=nn(32)){const r=D("message",e),{bytes:o,scalar:s}=ue(t),i=D("auxRand",n,32),c=le(s^Y(zt("BIP0340/aux",i))),f=zt("BIP0340/nonce",c,o,r),a=Rt(Y(f));if(a===Wt)throw new Error("sign failed: k is zero");const{bytes:u,scalar:l}=ue(a),b=yn(u,o,r),y=new Uint8Array(64);if(y.set(u,0),y.set(le(Rt(l+b*s)),32),!bn(y,r,o))throw new Error("sign: Invalid signature produced");return y}function bn(e,t,n){const r=D("signature",e,64),o=D("message",t),s=D("publicKey",n,32);try{const i=pn(Y(s)),c=Y(r.subarray(0,32));if(!gn(c))return!1;const f=Y(r.subarray(32,64));if(!Br(f))return!1;const a=yn(le(c),$e(i),o),u=$r(i,f,Rt(-a));return!(!u||!u.hasEvenY()||u.toAffine().x!==c)}catch{return!1}}const No={getPublicKey:Ir,sign:Ur,verify:bn,utils:{randomPrivateKey:Be.utils.randomPrivateKey,lift_x:pn,pointToBytes:$e,numberToBytesBE:mt,bytesToNumberBE:Y,taggedHash:zt,mod:Z}},ee=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ue=e=>e instanceof Uint8Array,ne=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),it=(e,t)=>e<<32-t|e>>>t,vr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!vr)throw new Error("Non little-endian hardware is not supported");const Lr=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function _o(e){if(!Ue(e))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=Lr[e[n]];return t}function Co(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let r=0;r<n.length;r++){const o=r*2,s=e.slice(o,o+2),i=Number.parseInt(s,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");n[r]=i}return n}function Sr(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function qt(e){if(typeof e=="string"&&(e=Sr(e)),!Ue(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}function Ro(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!Ue(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}class xn{clone(){return this._cloneInto()}}function En(e){const t=r=>e().update(qt(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function qo(e=32){if(ee&&typeof ee.getRandomValues=="function")return ee.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}function he(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function Hr(e){if(typeof e!="boolean")throw new Error(`Expected boolean, not ${e}`)}function mn(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function Tr(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");he(e.outputLen),he(e.blockLen)}function Or(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Nr(e,t){mn(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const ft={number:he,bool:Hr,bytes:mn,hash:Tr,exists:Or,output:Nr};function _r(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(n>>o&s),c=Number(n&s),f=r?4:0,a=r?0:4;e.setUint32(t+f,i,r),e.setUint32(t+a,c,r)}class Cr extends xn{constructor(t,n,r,o){super(),this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=ne(this.buffer)}update(t){ft.exists(this);const{view:n,buffer:r,blockLen:o}=this;t=qt(t);const s=t.length;for(let i=0;i<s;){const c=Math.min(o-this.pos,s-i);if(c===o){const f=ne(t);for(;o<=s-i;i+=o)this.process(f,i);continue}r.set(t.subarray(i,i+c),this.pos),this.pos+=c,i+=c,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){ft.exists(this),ft.output(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;n[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(r,0),i=0);for(let l=i;l<o;l++)n[l]=0;_r(r,o-8,BigInt(this.length*8),s),this.process(r,0);const c=ne(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<a;l++)c.setUint32(4*l,u[l],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:i,pos:c}=this;return t.length=o,t.pos=c,t.finished=s,t.destroyed=i,o%n&&t.buffer.set(r),t}}const Rr=(e,t,n)=>e&t^~e&n,qr=(e,t,n)=>e&t^e&n^t&n,jr=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),yt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),bt=new Uint32Array(64);class An extends Cr{constructor(){super(64,32,8,!1),this.A=yt[0]|0,this.B=yt[1]|0,this.C=yt[2]|0,this.D=yt[3]|0,this.E=yt[4]|0,this.F=yt[5]|0,this.G=yt[6]|0,this.H=yt[7]|0}get(){const{A:t,B:n,C:r,D:o,E:s,F:i,G:c,H:f}=this;return[t,n,r,o,s,i,c,f]}set(t,n,r,o,s,i,c,f){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=i|0,this.G=c|0,this.H=f|0}process(t,n){for(let l=0;l<16;l++,n+=4)bt[l]=t.getUint32(n,!1);for(let l=16;l<64;l++){const b=bt[l-15],y=bt[l-2],w=it(b,7)^it(b,18)^b>>>3,h=it(y,17)^it(y,19)^y>>>10;bt[l]=h+bt[l-7]+w+bt[l-16]|0}let{A:r,B:o,C:s,D:i,E:c,F:f,G:a,H:u}=this;for(let l=0;l<64;l++){const b=it(c,6)^it(c,11)^it(c,25),y=u+b+Rr(c,f,a)+jr[l]+bt[l]|0,h=(it(r,2)^it(r,13)^it(r,22))+qr(r,o,s)|0;u=a,a=f,f=c,c=i+y|0,i=s,s=o,o=r,r=y+h|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,i=i+this.D|0,c=c+this.E|0,f=f+this.F|0,a=a+this.G|0,u=u+this.H|0,this.set(r,o,s,i,c,f,a,u)}roundClean(){bt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class kr extends An{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const jo=En(()=>new An);En(()=>new kr);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _t(e){if(!Number.isSafeInteger(e))throw new Error(`Wrong integer: ${e}`)}function ht(...e){const t=(o,s)=>i=>o(s(i)),n=Array.from(e).reverse().reduce((o,s)=>o?t(o,s.encode):s.encode,void 0),r=e.reduce((o,s)=>o?t(o,s.decode):s.decode,void 0);return{encode:n,decode:r}}function dt(e){return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return t.map(n=>{if(_t(n),n<0||n>=e.length)throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${e.length})`);return e[n]})},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("alphabet.decode input should be array of strings");return t.map(n=>{if(typeof n!="string")throw new Error(`alphabet.decode: not string element=${n}`);const r=e.indexOf(n);if(r===-1)throw new Error(`Unknown letter: "${n}". Allowed: ${e}`);return r})}}}function wt(e=""){if(typeof e!="string")throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("join.encode input should be array of strings");for(let n of t)if(typeof n!="string")throw new Error(`join.encode: non-string input=${n}`);return t.join(e)},decode:t=>{if(typeof t!="string")throw new Error("join.decode input should be string");return t.split(e)}}}function Ft(e,t="="){if(_t(e),typeof t!="string")throw new Error("padding chr should be string");return{encode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let r of n)if(typeof r!="string")throw new Error(`padding.encode: non-string input=${r}`);for(;n.length*e%8;)n.push(t);return n},decode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let o of n)if(typeof o!="string")throw new Error(`padding.decode: non-string input=${o}`);let r=n.length;if(r*e%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;r>0&&n[r-1]===t;r--)if(!((r-1)*e%8))throw new Error("Invalid padding: string has too much padding");return n.slice(0,r)}}}function Bn(e){if(typeof e!="function")throw new Error("normalize fn should be function");return{encode:t=>t,decode:t=>e(t)}}function Me(e,t,n){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(e))throw new Error("convertRadix: data should be array");if(!e.length)return[];let r=0;const o=[],s=Array.from(e);for(s.forEach(i=>{if(_t(i),i<0||i>=t)throw new Error(`Wrong integer: ${i}`)});;){let i=0,c=!0;for(let f=r;f<s.length;f++){const a=s[f],u=t*i+a;if(!Number.isSafeInteger(u)||t*i/t!==i||u-a!==t*i)throw new Error("convertRadix: carry overflow");if(i=u%n,s[f]=Math.floor(u/n),!Number.isSafeInteger(s[f])||s[f]*n+i!==u)throw new Error("convertRadix: carry overflow");if(c)s[f]?c=!1:r=f;else continue}if(o.push(i),c)break}for(let i=0;i<e.length-1&&e[i]===0;i++)o.push(0);return o.reverse()}const $n=(e,t)=>t?$n(t,e%t):e,Mt=(e,t)=>e+(t-$n(e,t));function de(e,t,n,r){if(!Array.isArray(e))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(Mt(t,n)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${Mt(t,n)}`);let o=0,s=0;const i=2**n-1,c=[];for(const f of e){if(_t(f),f>=2**t)throw new Error(`convertRadix2: invalid data word=${f} from=${t}`);if(o=o<<t|f,s+t>32)throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);for(s+=t;s>=n;s-=n)c.push((o>>s-n&i)>>>0);o&=2**s-1}if(o=o<<n-s&i,!r&&s>=t)throw new Error("Excess padding");if(!r&&o)throw new Error(`Non-zero padding: ${o}`);return r&&s>0&&c.push(o>>>0),c}function Pr(e){return _t(e),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return Me(Array.from(t),2**8,e)},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(Me(t,e,2**8))}}}function Bt(e,t=!1){if(_t(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(Mt(8,e)>32||Mt(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!(n instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return de(Array.from(n),8,e,!t)},decode:n=>{if(!Array.isArray(n)||n.length&&typeof n[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(de(n,e,8,t))}}}function Ze(e){if(typeof e!="function")throw new Error("unsafeWrapper fn should be function");return function(...t){try{return e.apply(null,t)}catch{}}}const Vr=ht(Bt(4),dt("0123456789ABCDEF"),wt("")),Kr=ht(Bt(5),dt("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),Ft(5),wt(""));ht(Bt(5),dt("0123456789ABCDEFGHIJKLMNOPQRSTUV"),Ft(5),wt(""));ht(Bt(5),dt("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),wt(""),Bn(e=>e.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const zr=ht(Bt(6),dt("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),Ft(6),wt("")),Mr=ht(Bt(6),dt("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),Ft(6),wt("")),ve=e=>ht(Pr(58),dt(e),wt("")),we=ve("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");ve("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");ve("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const De=[0,2,3,5,6,7,9,10,11],Zr={encode(e){let t="";for(let n=0;n<e.length;n+=8){const r=e.subarray(n,n+8);t+=we.encode(r).padStart(De[r.length],"1")}return t},decode(e){let t=[];for(let n=0;n<e.length;n+=11){const r=e.slice(n,n+11),o=De.indexOf(r.length),s=we.decode(r);for(let i=0;i<s.length-o;i++)if(s[i]!==0)throw new Error("base58xmr: wrong padding");t=t.concat(Array.from(s.slice(s.length-o)))}return Uint8Array.from(t)}},ge=ht(dt("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),wt("")),Ge=[996825010,642813549,513874426,1027748829,705979059];function Ct(e){const t=e>>25;let n=(e&33554431)<<5;for(let r=0;r<Ge.length;r++)(t>>r&1)===1&&(n^=Ge[r]);return n}function We(e,t,n=1){const r=e.length;let o=1;for(let s=0;s<r;s++){const i=e.charCodeAt(s);if(i<33||i>126)throw new Error(`Invalid prefix (${e})`);o=Ct(o)^i>>5}o=Ct(o);for(let s=0;s<r;s++)o=Ct(o)^e.charCodeAt(s)&31;for(let s of t)o=Ct(o)^s;for(let s=0;s<6;s++)o=Ct(o);return o^=n,ge.encode(de([o%2**30],30,5,!1))}function In(e){const t=e==="bech32"?1:734539939,n=Bt(5),r=n.decode,o=n.encode,s=Ze(r);function i(u,l,b=90){if(typeof u!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof u}`);if(!Array.isArray(l)||l.length&&typeof l[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof l}`);const y=u.length+7+l.length;if(b!==!1&&y>b)throw new TypeError(`Length ${y} exceeds limit ${b}`);return u=u.toLowerCase(),`${u}1${ge.encode(l)}${We(u,l,t)}`}function c(u,l=90){if(typeof u!="string")throw new Error(`bech32.decode input should be string, not ${typeof u}`);if(u.length<8||l!==!1&&u.length>l)throw new TypeError(`Wrong string length: ${u.length} (${u}). Expected (8..${l})`);const b=u.toLowerCase();if(u!==b&&u!==u.toUpperCase())throw new Error("String must be lowercase or uppercase");u=b;const y=u.lastIndexOf("1");if(y===0||y===-1)throw new Error('Letter "1" must be present between prefix and data only');const w=u.slice(0,y),h=u.slice(y+1);if(h.length<6)throw new Error("Data must be at least 6 characters long");const d=ge.decode(h).slice(0,-6),g=We(w,d,t);if(!h.endsWith(g))throw new Error(`Invalid checksum in ${u}: expected "${g}"`);return{prefix:w,words:d}}const f=Ze(c);function a(u){const{prefix:l,words:b}=c(u,!1);return{prefix:l,words:b,bytes:r(b)}}return{encode:i,decode:c,decodeToBytes:a,decodeUnsafe:f,fromWords:r,fromWordsUnsafe:s,toWords:o}}const ko=In("bech32");In("bech32m");const Dr={encode:e=>new TextDecoder().decode(e),decode:e=>new TextEncoder().encode(e)},Gr=ht(Bt(4),dt("0123456789abcdef"),wt(""),Bn(e=>{if(typeof e!="string"||e.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);return e.toLowerCase()})),Wr={utf8:Dr,hex:Gr,base16:Vr,base32:Kr,base64:zr,base64url:Mr,base58:we,base58xmr:Zr};`${Object.keys(Wr).join(", ")}`;function re(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function Fe(e){if(typeof e!="boolean")throw new Error(`boolean expected, not ${e}`)}function Un(e){return e instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"}function nt(e,...t){if(!Un(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}function Nt(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function Le(e,t){nt(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const V=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),Fr=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),Yr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Yr)throw new Error("Non little-endian hardware is not supported");function Se(e){if(typeof e!="string")throw new Error(`string expected, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function At(e){if(typeof e=="string")e=Se(e);else if(Un(e))e=e.slice();else throw new Error(`Uint8Array expected, got ${typeof e}`);return e}function Xr(e,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(e,t)}function Po(e,t){if(e.length!==t.length)return!1;let n=0;for(let r=0;r<e.length;r++)n|=e[r]^t[r];return n===0}const Qr=(e,t)=>(Object.assign(t,e),t),lt=16,He=new Uint8Array(16),ct=V(He),Jr=225,to=(e,t,n,r)=>{const o=r&1;return{s3:n<<31|r>>>1,s2:t<<31|n>>>1,s1:e<<31|t>>>1,s0:e>>>1^Jr<<24&-(o&1)}},et=e=>(e>>>0&255)<<24|(e>>>8&255)<<16|(e>>>16&255)<<8|e>>>24&255|0;function eo(e){e.reverse();const t=e[15]&1;let n=0;for(let r=0;r<e.length;r++){const o=e[r];e[r]=o>>>1|n,n=(o&1)<<7}return e[0]^=-t&225,e}const no=e=>e>64*1024?8:e>1024?4:2;class vn{constructor(t,n){this.blockLen=lt,this.outputLen=lt,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,t=At(t),nt(t,16);const r=Fr(t);let o=r.getUint32(0,!1),s=r.getUint32(4,!1),i=r.getUint32(8,!1),c=r.getUint32(12,!1);const f=[];for(let w=0;w<128;w++)f.push({s0:et(o),s1:et(s),s2:et(i),s3:et(c)}),{s0:o,s1:s,s2:i,s3:c}=to(o,s,i,c);const a=no(n||1024);if(![1,2,4,8].includes(a))throw new Error(`ghash: wrong window size=${a}, should be 2, 4 or 8`);this.W=a;const l=128/a,b=this.windowSize=2**a,y=[];for(let w=0;w<l;w++)for(let h=0;h<b;h++){let d=0,g=0,A=0,U=0;for(let H=0;H<a;H++){if(!(h>>>a-H-1&1))continue;const{s0:m,s1:B,s2:I,s3:N}=f[a*w+H];d^=m,g^=B,A^=I,U^=N}y.push({s0:d,s1:g,s2:A,s3:U})}this.t=y}_updateBlock(t,n,r,o){t^=this.s0,n^=this.s1,r^=this.s2,o^=this.s3;const{W:s,t:i,windowSize:c}=this;let f=0,a=0,u=0,l=0;const b=(1<<s)-1;let y=0;for(const w of[t,n,r,o])for(let h=0;h<4;h++){const d=w>>>8*h&255;for(let g=8/s-1;g>=0;g--){const A=d>>>s*g&b,{s0:U,s1:H,s2:T,s3:m}=i[y*c+A];f^=U,a^=H,u^=T,l^=m,y+=1}}this.s0=f,this.s1=a,this.s2=u,this.s3=l}update(t){t=At(t),Nt(this);const n=V(t),r=Math.floor(t.length/lt),o=t.length%lt;for(let s=0;s<r;s++)this._updateBlock(n[s*4+0],n[s*4+1],n[s*4+2],n[s*4+3]);return o&&(He.set(t.subarray(r*lt)),this._updateBlock(ct[0],ct[1],ct[2],ct[3]),ct.fill(0)),this}destroy(){const{t}=this;for(const n of t)n.s0=0,n.s1=0,n.s2=0,n.s3=0}digestInto(t){Nt(this),Le(t,this),this.finished=!0;const{s0:n,s1:r,s2:o,s3:s}=this,i=V(t);return i[0]=n,i[1]=r,i[2]=o,i[3]=s,t}digest(){const t=new Uint8Array(lt);return this.digestInto(t),this.destroy(),t}}class ro extends vn{constructor(t,n){t=At(t);const r=eo(t.slice());super(r,n),r.fill(0)}update(t){t=At(t),Nt(this);const n=V(t),r=t.length%lt,o=Math.floor(t.length/lt);for(let s=0;s<o;s++)this._updateBlock(et(n[s*4+3]),et(n[s*4+2]),et(n[s*4+1]),et(n[s*4+0]));return r&&(He.set(t.subarray(o*lt)),this._updateBlock(et(ct[3]),et(ct[2]),et(ct[1]),et(ct[0])),ct.fill(0)),this}digestInto(t){Nt(this),Le(t,this),this.finished=!0;const{s0:n,s1:r,s2:o,s3:s}=this,i=V(t);return i[0]=n,i[1]=r,i[2]=o,i[3]=s,t.reverse()}}function Ln(e){const t=(r,o)=>e(o,r.length).update(At(r)).digest(),n=e(new Uint8Array(16),0);return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=(r,o)=>e(r,o),t}Ln((e,t)=>new vn(e,t));Ln((e,t)=>new ro(e,t));const Et=16,oo=283;function Te(e){return e<<1^oo&-(e>>7)}function Ht(e,t){let n=0;for(;t>0;t>>=1)n^=e&-(t&1),e=Te(e);return n}const pe=(()=>{let e=new Uint8Array(256);for(let n=0,r=1;n<256;n++,r^=Te(r))e[n]=r;const t=new Uint8Array(256);t[0]=99;for(let n=0;n<255;n++){let r=e[255-n];r|=r<<8,t[e[n]]=(r^r>>4^r>>5^r>>6^r>>7^99)&255}return t})(),so=pe.map((e,t)=>pe.indexOf(t)),io=e=>e<<24|e>>>8,oe=e=>e<<8|e>>>24;function Sn(e,t){if(e.length!==256)throw new Error("Wrong sbox length");const n=new Uint32Array(256).map((a,u)=>t(e[u])),r=n.map(oe),o=r.map(oe),s=o.map(oe),i=new Uint32Array(256*256),c=new Uint32Array(256*256),f=new Uint16Array(256*256);for(let a=0;a<256;a++)for(let u=0;u<256;u++){const l=a*256+u;i[l]=n[a]^r[u],c[l]=o[a]^s[u],f[l]=e[a]<<8|e[u]}return{sbox:e,sbox2:f,T0:n,T1:r,T2:o,T3:s,T01:i,T23:c}}const Oe=Sn(pe,e=>Ht(e,3)<<24|e<<16|e<<8|Ht(e,2)),Hn=Sn(so,e=>Ht(e,11)<<24|Ht(e,13)<<16|Ht(e,9)<<8|Ht(e,14)),co=(()=>{const e=new Uint8Array(16);for(let t=0,n=1;t<16;t++,n=Te(n))e[t]=n;return e})();function Tn(e){nt(e);const t=e.length;if(![16,24,32].includes(t))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t}`);const{sbox2:n}=Oe,r=V(e),o=r.length,s=c=>at(n,c,c,c,c),i=new Uint32Array(t+28);i.set(r);for(let c=o;c<i.length;c++){let f=i[c-1];c%o===0?f=s(io(f))^co[c/o-1]:o>6&&c%o===4&&(f=s(f)),i[c]=i[c-o]^f}return i}function fo(e){const t=Tn(e),n=t.slice(),r=t.length,{sbox2:o}=Oe,{T0:s,T1:i,T2:c,T3:f}=Hn;for(let a=0;a<r;a+=4)for(let u=0;u<4;u++)n[a+u]=t[r-a-4+u];t.fill(0);for(let a=4;a<r-4;a++){const u=n[a],l=at(o,u,u,u,u);n[a]=s[l&255]^i[l>>>8&255]^c[l>>>16&255]^f[l>>>24]}return n}function xt(e,t,n,r,o,s){return e[n<<8&65280|r>>>8&255]^t[o>>>8&65280|s>>>24&255]}function at(e,t,n,r,o){return e[t&255|n&65280]|e[r>>>16&255|o>>>16&65280]<<16}function Ye(e,t,n,r,o){const{sbox2:s,T01:i,T23:c}=Oe;let f=0;t^=e[f++],n^=e[f++],r^=e[f++],o^=e[f++];const a=e.length/4-2;for(let w=0;w<a;w++){const h=e[f++]^xt(i,c,t,n,r,o),d=e[f++]^xt(i,c,n,r,o,t),g=e[f++]^xt(i,c,r,o,t,n),A=e[f++]^xt(i,c,o,t,n,r);t=h,n=d,r=g,o=A}const u=e[f++]^at(s,t,n,r,o),l=e[f++]^at(s,n,r,o,t),b=e[f++]^at(s,r,o,t,n),y=e[f++]^at(s,o,t,n,r);return{s0:u,s1:l,s2:b,s3:y}}function ao(e,t,n,r,o){const{sbox2:s,T01:i,T23:c}=Hn;let f=0;t^=e[f++],n^=e[f++],r^=e[f++],o^=e[f++];const a=e.length/4-2;for(let w=0;w<a;w++){const h=e[f++]^xt(i,c,t,o,r,n),d=e[f++]^xt(i,c,n,t,o,r),g=e[f++]^xt(i,c,r,n,t,o),A=e[f++]^xt(i,c,o,r,n,t);t=h,n=d,r=g,o=A}const u=e[f++]^at(s,t,o,r,n),l=e[f++]^at(s,n,t,o,r),b=e[f++]^at(s,r,n,t,o),y=e[f++]^at(s,o,r,n,t);return{s0:u,s1:l,s2:b,s3:y}}function On(e,t){if(!t)return new Uint8Array(e);if(nt(t),t.length<e)throw new Error(`aes: wrong destination length, expected at least ${e}, got: ${t.length}`);return t}function lo(e){if(nt(e),e.length%Et!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${Et}`)}function uo(e,t,n){let r=e.length;const o=r%Et;if(!t&&o!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const s=V(e);if(t){let f=Et-o;f||(f=Et),r=r+f}const i=On(r,n),c=V(i);return{b:s,o:c,out:i}}function ho(e,t){if(!t)return e;const n=e.length;if(!n)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=e[n-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const o=e.subarray(0,-r);for(let s=0;s<r;s++)if(e[n-s-1]!==r)throw new Error("aes/pcks5: wrong padding");return o}function wo(e){const t=new Uint8Array(16),n=V(t);t.set(e);const r=Et-e.length;for(let o=Et-r;o<Et;o++)t[o]=r;return n}const Vo=Qr({blockSize:16,nonceLength:16},function(t,n,r={}){nt(t),nt(n,16);const o=!r.disablePadding;return{encrypt:(s,i)=>{const c=Tn(t),{b:f,o:a,out:u}=uo(s,o,i),l=V(n);let b=l[0],y=l[1],w=l[2],h=l[3],d=0;for(;d+4<=f.length;)b^=f[d+0],y^=f[d+1],w^=f[d+2],h^=f[d+3],{s0:b,s1:y,s2:w,s3:h}=Ye(c,b,y,w,h),a[d++]=b,a[d++]=y,a[d++]=w,a[d++]=h;if(o){const g=wo(s.subarray(d*4));b^=g[0],y^=g[1],w^=g[2],h^=g[3],{s0:b,s1:y,s2:w,s3:h}=Ye(c,b,y,w,h),a[d++]=b,a[d++]=y,a[d++]=w,a[d++]=h}return c.fill(0),u},decrypt:(s,i)=>{lo(s);const c=fo(t),f=V(n),a=On(s.length,i),u=V(s),l=V(a);let b=f[0],y=f[1],w=f[2],h=f[3];for(let d=0;d+4<=u.length;){const g=b,A=y,U=w,H=h;b=u[d+0],y=u[d+1],w=u[d+2],h=u[d+3];const{s0:T,s1:m,s2:B,s3:I}=ao(c,b,y,w,h);l[d++]=T^g,l[d++]=m^A,l[d++]=B^U,l[d++]=I^H}return c.fill(0),ho(a,o)}}}),M=(e,t)=>e[t++]&255|(e[t++]&255)<<8;class go{constructor(t){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,t=At(t),nt(t,32);const n=M(t,0),r=M(t,2),o=M(t,4),s=M(t,6),i=M(t,8),c=M(t,10),f=M(t,12),a=M(t,14);this.r[0]=n&8191,this.r[1]=(n>>>13|r<<3)&8191,this.r[2]=(r>>>10|o<<6)&7939,this.r[3]=(o>>>7|s<<9)&8191,this.r[4]=(s>>>4|i<<12)&255,this.r[5]=i>>>1&8190,this.r[6]=(i>>>14|c<<2)&8191,this.r[7]=(c>>>11|f<<5)&8065,this.r[8]=(f>>>8|a<<8)&8191,this.r[9]=a>>>5&127;for(let u=0;u<8;u++)this.pad[u]=M(t,16+2*u)}process(t,n,r=!1){const o=r?0:2048,{h:s,r:i}=this,c=i[0],f=i[1],a=i[2],u=i[3],l=i[4],b=i[5],y=i[6],w=i[7],h=i[8],d=i[9],g=M(t,n+0),A=M(t,n+2),U=M(t,n+4),H=M(t,n+6),T=M(t,n+8),m=M(t,n+10),B=M(t,n+12),I=M(t,n+14);let N=s[0]+(g&8191),S=s[1]+((g>>>13|A<<3)&8191),v=s[2]+((A>>>10|U<<6)&8191),_=s[3]+((U>>>7|H<<9)&8191),C=s[4]+((H>>>4|T<<12)&8191),j=s[5]+(T>>>1&8191),p=s[6]+((T>>>14|m<<2)&8191),x=s[7]+((m>>>11|B<<5)&8191),$=s[8]+((B>>>8|I<<8)&8191),L=s[9]+(I>>>5|o),E=0,O=E+N*c+S*(5*d)+v*(5*h)+_*(5*w)+C*(5*y);E=O>>>13,O&=8191,O+=j*(5*b)+p*(5*l)+x*(5*u)+$*(5*a)+L*(5*f),E+=O>>>13,O&=8191;let q=E+N*f+S*c+v*(5*d)+_*(5*h)+C*(5*w);E=q>>>13,q&=8191,q+=j*(5*y)+p*(5*b)+x*(5*l)+$*(5*u)+L*(5*a),E+=q>>>13,q&=8191;let R=E+N*a+S*f+v*c+_*(5*d)+C*(5*h);E=R>>>13,R&=8191,R+=j*(5*w)+p*(5*y)+x*(5*b)+$*(5*l)+L*(5*u),E+=R>>>13,R&=8191;let K=E+N*u+S*a+v*f+_*c+C*(5*d);E=K>>>13,K&=8191,K+=j*(5*h)+p*(5*w)+x*(5*y)+$*(5*b)+L*(5*l),E+=K>>>13,K&=8191;let G=E+N*l+S*u+v*a+_*f+C*c;E=G>>>13,G&=8191,G+=j*(5*d)+p*(5*h)+x*(5*w)+$*(5*y)+L*(5*b),E+=G>>>13,G&=8191;let X=E+N*b+S*l+v*u+_*a+C*f;E=X>>>13,X&=8191,X+=j*c+p*(5*d)+x*(5*h)+$*(5*w)+L*(5*y),E+=X>>>13,X&=8191;let Q=E+N*y+S*b+v*l+_*u+C*a;E=Q>>>13,Q&=8191,Q+=j*f+p*c+x*(5*d)+$*(5*h)+L*(5*w),E+=Q>>>13,Q&=8191;let W=E+N*w+S*y+v*b+_*l+C*u;E=W>>>13,W&=8191,W+=j*a+p*f+x*c+$*(5*d)+L*(5*h),E+=W>>>13,W&=8191;let ot=E+N*h+S*w+v*y+_*b+C*l;E=ot>>>13,ot&=8191,ot+=j*u+p*a+x*f+$*c+L*(5*d),E+=ot>>>13,ot&=8191;let F=E+N*d+S*h+v*w+_*y+C*b;E=F>>>13,F&=8191,F+=j*l+p*u+x*a+$*f+L*c,E+=F>>>13,F&=8191,E=(E<<2)+E|0,E=E+O|0,O=E&8191,E=E>>>13,q+=E,s[0]=O,s[1]=q,s[2]=R,s[3]=K,s[4]=G,s[5]=X,s[6]=Q,s[7]=W,s[8]=ot,s[9]=F}finalize(){const{h:t,pad:n}=this,r=new Uint16Array(10);let o=t[1]>>>13;t[1]&=8191;for(let c=2;c<10;c++)t[c]+=o,o=t[c]>>>13,t[c]&=8191;t[0]+=o*5,o=t[0]>>>13,t[0]&=8191,t[1]+=o,o=t[1]>>>13,t[1]&=8191,t[2]+=o,r[0]=t[0]+5,o=r[0]>>>13,r[0]&=8191;for(let c=1;c<10;c++)r[c]=t[c]+o,o=r[c]>>>13,r[c]&=8191;r[9]-=8192;let s=(o^1)-1;for(let c=0;c<10;c++)r[c]&=s;s=~s;for(let c=0;c<10;c++)t[c]=t[c]&s|r[c];t[0]=(t[0]|t[1]<<13)&65535,t[1]=(t[1]>>>3|t[2]<<10)&65535,t[2]=(t[2]>>>6|t[3]<<7)&65535,t[3]=(t[3]>>>9|t[4]<<4)&65535,t[4]=(t[4]>>>12|t[5]<<1|t[6]<<14)&65535,t[5]=(t[6]>>>2|t[7]<<11)&65535,t[6]=(t[7]>>>5|t[8]<<8)&65535,t[7]=(t[8]>>>8|t[9]<<5)&65535;let i=t[0]+n[0];t[0]=i&65535;for(let c=1;c<8;c++)i=(t[c]+n[c]|0)+(i>>>16)|0,t[c]=i&65535}update(t){Nt(this);const{buffer:n,blockLen:r}=this;t=At(t);const o=t.length;for(let s=0;s<o;){const i=Math.min(r-this.pos,o-s);if(i===r){for(;r<=o-s;s+=r)this.process(t,s);continue}n.set(t.subarray(s,s+i),this.pos),this.pos+=i,s+=i,this.pos===r&&(this.process(n,0,!1),this.pos=0)}return this}destroy(){this.h.fill(0),this.r.fill(0),this.buffer.fill(0),this.pad.fill(0)}digestInto(t){Nt(this),Le(t,this),this.finished=!0;const{buffer:n,h:r}=this;let{pos:o}=this;if(o){for(n[o++]=1;o<16;o++)n[o]=0;this.process(n,0,!0)}this.finalize();let s=0;for(let i=0;i<8;i++)t[s++]=r[i]>>>0,t[s++]=r[i]>>>8;return t}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}}function po(e){const t=(r,o)=>e(o).update(At(r)).digest(),n=e(new Uint8Array(32));return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=r=>e(r),t}po(e=>new go(e));const yo=Se("expand 16-byte k"),bo=Se("expand 32-byte k"),xo=V(yo),Eo=V(bo);function k(e,t){return e<<t|e>>>32-t}function ye(e){return e.byteOffset%4===0}const kt=64,mo=16,Nn=2**32-1,Xe=new Uint32Array;function Ao(e,t,n,r,o,s,i,c){const f=o.length,a=new Uint8Array(kt),u=V(a),l=ye(o)&&ye(s),b=l?V(o):Xe,y=l?V(s):Xe;for(let w=0;w<f;i++){if(e(t,n,r,u,i,c),i>=Nn)throw new Error("arx: counter overflow");const h=Math.min(kt,f-w);if(l&&h===kt){const d=w/4;if(w%4!==0)throw new Error("arx: invalid block position");for(let g=0,A;g<mo;g++)A=d+g,y[A]=b[A]^u[g];w+=kt;continue}for(let d=0,g;d<h;d++)g=w+d,s[g]=o[g]^a[d];w+=h}}function Bo(e,t){const{allowShortKeys:n,extendNonceFn:r,counterLength:o,counterRight:s,rounds:i}=Xr({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof e!="function")throw new Error("core must be a function");return re(o),re(i),Fe(s),Fe(n),(c,f,a,u,l=0)=>{nt(c),nt(f),nt(a);const b=a.length;if(u||(u=new Uint8Array(b)),nt(u),re(l),l<0||l>=Nn)throw new Error("arx: counter overflow");if(u.length<b)throw new Error(`arx: output (${u.length}) is shorter than data (${b})`);const y=[];let w=c.length,h,d;if(w===32)h=c.slice(),y.push(h),d=Eo;else if(w===16&&n)h=new Uint8Array(32),h.set(c),h.set(c,16),d=xo,y.push(h);else throw new Error(`arx: invalid 32-byte key, got length=${w}`);ye(f)||(f=f.slice(),y.push(f));const g=V(h);if(r){if(f.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(d,g,V(f.subarray(0,16)),g),f=f.subarray(16)}const A=16-o;if(A!==f.length)throw new Error(`arx: nonce must be ${A} or 16 bytes`);if(A!==12){const H=new Uint8Array(12);H.set(f,s?0:12-f.length),f=H,y.push(f)}const U=V(f);for(Ao(e,d,g,U,a,u,l,i);y.length>0;)y.pop().fill(0);return u}}function $o(e,t,n,r,o,s=20){let i=e[0],c=e[1],f=e[2],a=e[3],u=t[0],l=t[1],b=t[2],y=t[3],w=t[4],h=t[5],d=t[6],g=t[7],A=o,U=n[0],H=n[1],T=n[2],m=i,B=c,I=f,N=a,S=u,v=l,_=b,C=y,j=w,p=h,x=d,$=g,L=A,E=U,O=H,q=T;for(let K=0;K<s;K+=2)m=m+S|0,L=k(L^m,16),j=j+L|0,S=k(S^j,12),m=m+S|0,L=k(L^m,8),j=j+L|0,S=k(S^j,7),B=B+v|0,E=k(E^B,16),p=p+E|0,v=k(v^p,12),B=B+v|0,E=k(E^B,8),p=p+E|0,v=k(v^p,7),I=I+_|0,O=k(O^I,16),x=x+O|0,_=k(_^x,12),I=I+_|0,O=k(O^I,8),x=x+O|0,_=k(_^x,7),N=N+C|0,q=k(q^N,16),$=$+q|0,C=k(C^$,12),N=N+C|0,q=k(q^N,8),$=$+q|0,C=k(C^$,7),m=m+v|0,q=k(q^m,16),x=x+q|0,v=k(v^x,12),m=m+v|0,q=k(q^m,8),x=x+q|0,v=k(v^x,7),B=B+_|0,L=k(L^B,16),$=$+L|0,_=k(_^$,12),B=B+_|0,L=k(L^B,8),$=$+L|0,_=k(_^$,7),I=I+C|0,E=k(E^I,16),j=j+E|0,C=k(C^j,12),I=I+C|0,E=k(E^I,8),j=j+E|0,C=k(C^j,7),N=N+S|0,O=k(O^N,16),p=p+O|0,S=k(S^p,12),N=N+S|0,O=k(O^N,8),p=p+O|0,S=k(S^p,7);let R=0;r[R++]=i+m|0,r[R++]=c+B|0,r[R++]=f+I|0,r[R++]=a+N|0,r[R++]=u+S|0,r[R++]=l+v|0,r[R++]=b+_|0,r[R++]=y+C|0,r[R++]=w+j|0,r[R++]=h+p|0,r[R++]=d+x|0,r[R++]=g+$|0,r[R++]=A+L|0,r[R++]=U+E|0,r[R++]=H+O|0,r[R++]=T+q|0}const Ko=Bo($o,{counterRight:!1,counterLength:4,allowShortKeys:!1});class _n extends xn{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,ft.hash(t);const r=qt(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=t.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),s.fill(0)}update(t){return ft.exists(this),this.iHash.update(t),this}digestInto(t){ft.exists(this),ft.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:c}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=i,t.outputLen=c,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ne=(e,t,n)=>new _n(e,t).update(n).digest();Ne.create=(e,t)=>new _n(e,t);function zo(e,t,n){return ft.hash(e),n===void 0&&(n=new Uint8Array(e.outputLen)),Ne(e,qt(n),qt(t))}const se=new Uint8Array([0]),Qe=new Uint8Array;function Mo(e,t,n,r=32){if(ft.hash(e),ft.number(r),r>255*e.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(r/e.outputLen);n===void 0&&(n=Qe);const s=new Uint8Array(o*e.outputLen),i=Ne.create(e,t),c=i._cloneInto(),f=new Uint8Array(i.outputLen);for(let a=0;a<o;a++)se[0]=a+1,c.update(a===0?Qe:f).update(n).update(se).digestInto(f),s.set(f,e.outputLen*a),i._cloneInto(c);return i.destroy(),c.destroy(),f.fill(0),se.fill(0),s.slice(0,r)}export{_o as a,ko as b,Ro as c,Vo as d,zr as e,jo as f,No as g,Co as h,zo as i,Mo as j,Ne as k,Ko as l,Po as m,Io as n,Uo as o,vo as p,qo as r,Be as s,Sr as u};
